#!/usr/bin/env python
#------------------------------------------------------------------------------
# Brain Workshop: a Dual N-Back game in Python
#
# Tutorial, installation instructions & links to the dual n-back community
# are available at the Brain Workshop web site:
#
#       http://brainworkshop.sourceforge.net/
#
# Also see Readme.txt.
#
# Copyright (C) 2009: Paul Hoskinson (plhosk@gmail.com) 
#
# The code is GPL licensed (http://www.gnu.org/copyleft/gpl.html)
#------------------------------------------------------------------------------

VERSION = '4.7'

import random, os, sys, imp, socket, urllib2, webbrowser, time, math, ConfigParser, StringIO, traceback
import cPickle as pickle
from decimal import Decimal
from time import strftime
from datetime import date

# Clinical mode?  Clinical mode sets JAEGGI_MODE = True, enforces a minimal user
# interface, and saves results into a binary file (default 'logfile.dat') which
# should be more difficult to tamper with.
CLINICAL_MODE = False

# Internal static options not available in config file.
CONFIG_OVERWRITE_IF_OLDER_THAN = 4.7
NOVBO = True
VSYNC = False
FOLDER_RES = 'res'
FOLDER_DATA = 'data'
CONFIGFILE = 'config.ini'
STATS_BINARY = 'logfile.dat'
#CHARTFILE = {2:'chart-02-dnb.txt', 3:'chart-03-tnb.txt', 4:'chart-04-dlnb.txt', 5:'chart-05-tlnb.txt',
             #6:'chart-06-qlnb.txt',7:'chart-07-anb.txt', 8:'chart-08-danb.txt', 9:'chart-09-tanb.txt',
             #10:'chart-10-ponb.txt', 11:'chart-11-aunb.txt'}
ATTEMPT_TO_SAVE_STATS = True
STATS_SEPARATOR = ','
WEB_SITE = 'http://brainworkshop.sourceforge.net/'
WEB_TUTORIAL = 'http://brainworkshop.sourceforge.net/#tutorial'
CLINICAL_TUTORIAL = WEB_TUTORIAL # FIXME: Add tutorial catered to clinical trials
WEB_VERSION_CHECK = 'http://brainworkshop.sourceforge.net/version.txt'
WEB_PYGLET_DOWNLOAD = 'http://pyglet.org/download.html'
WEB_FORUM = 'http://groups.google.com/group/brain-training'
WEB_MORSE = 'http://en.wikipedia.org/wiki/Morse_code'
TIMEOUT_SILENT = 3
TICKS_MIN = 3
TICKS_MAX = 50
TICK_DURATION = 0.1
                                           
# some functions to assist in path determination
def main_is_frozen():
    return (hasattr(sys, "frozen") or # new py2exe
        hasattr(sys, "importers") # old py2exe
        or imp.is_frozen("__main__")) # tools/freeze
def get_main_dir():
    if main_is_frozen():
        return os.path.dirname(sys.executable)
    return sys.path[0]    
def get_data_dir():
    try:
        return sys.argv[sys.argv.index('--datadir') + 1]
    except:
        return os.path.join(get_main_dir(), FOLDER_DATA)
def get_res_dir():
    try:
        return sys.argv[sys.argv.index('--resdir') + 1]
    except:
        return os.path.join(get_main_dir(), FOLDER_RES)
def quit_with_error(message='', postmessage='', quit=True, trace=True):
    if message:     print >> sys.stderr, message + '\n'
    if trace:       
        print >> sys.stderr, "Full text of error:\n" 
        traceback.print_exc()
    if postmessage: print >> sys.stderr, '\n\n' + postmessage
    if quit:        sys.exit(1)

CONFIGFILE_DEFAULT_CONTENTS = """
######################################################################
# Brain Workshop configuration file
# generated by Brain Workshop """ + VERSION + """
# 
# To change configuration options:
#   1. Edit this file as desired,
#   2. Save the file,
#   3. Launch Brain Workshop to see the changes.
#
# Every line beginning with # is ignored by the program.
#
# Please see the Brain Workshop web site for more information:
#       http://brainworkshop.sourceforge.net
#
# The configuration options begin below.
######################################################################
[DEFAULT]

# Jaeggi-style interface with default scoring model? 
# Choose either this option or JAEGGI_MODE but not both.
# This mode allows access to Manual mode, the extra sound sets, and the
# additional game modes of Brain Workshop while presenting the game in
# the more challenging Jaeggi-style interface featured in the original study.
# With the default BW scoring model, the visual and auditory sequences are
# more randomized and unpredictable than they are in Jaeggi mode.
# The only effect of this option is to set the following options:
#   ANIMATE_SQUARES = False, OLD_STYLE_SQUARES = True,
#   OLD_STYLE_SHARP_CORNERS = True, SHOW_FEEDBACK = False,
#   GRIDLINES = False, CROSSHAIRS = True, BLACK_BACKGROUND = True,
#   WINDOW_FULLSCREEN = True, HIDE_TEXT = True, FIELD_EXPAND = True
# Default: False
JAEGGI_INTERFACE_DEFAULT_SCORING = False

# Jaeggi mode?
# Choose either this option or JAEGGI_INTERFACE_DEFAULT_SCORING but not both.
# This mode emulates the scoring model used in the original study protocol.
# It counts non-matches with no inputs as correct (instead of ignoring them).
# It also forces 4 visual matches, 4 auditory matches, and 2 simultaneous
# matches per session, resulting in less randomized and more predictable
# sequences than in the default BW scoring model.
# Different thresholds are used to reflect the modified scoring system.
# Access to Manual mode, additional game modes and sound sets is disabled 
# in Jaeggi mode.
# Default: False
JAEGGI_MODE = False

# In Jaeggi Mode, adjust the default appearance and sounds of Brain Workshop
# to emulate the original software used in the study?
# If this is enabled, the following options will be set:
#    USE_LETTERS = True, USE_NUMBERS = False, USE_NATO = False,
#    USE_PIANO = False, USE_MORSE = False, ANIMATE_SQUARES = False,
#    OLD_STYLE_SQUARES = True, OLD_STYLE_SHARP_CORNERS = True,
#    SHOW_FEEDBACK = False, GRIDLINES = False, CROSSHAIRS = True
# (note: this option only takes effect if JAEGGI_MODE is set to True)
# Default: True
JAEGGI_FORCE_OPTIONS = True 

# In Jaeggi Mode, further adjust the appearance to match the original
# software as closely as possible?
# If this is enabled, the following options will be set:
#    BLACK_BACKGROUND = True, WINDOW_FULLSCREEN = True,
#    HIDE_TEXT = True, FIELD_EXPAND = True
# (note: this option only takes effect if JAEGGI_MODE is set to True)
# Default: True
JAEGGI_FORCE_OPTIONS_ADDITIONAL = True

# This selects which sounds to use for audio n-back tasks.
# Select any combination of letters, numbers, the NATO Phonetic Alphabet
# (Alpha, Bravo, Charlie, etc), the C scale on piano, and morse code.
USE_LETTERS = True
USE_NUMBERS = False
USE_NATO = False
USE_PIANO = False
USE_MORSE = False

# Sound configuration for the Dual Audio (A-A) task.
CHANNEL_AUDIO = 'left'
CHANNEL_AUDIO2 = 'right'
USE_LETTERS_2 = True
USE_NUMBERS_2 = False
USE_NATO_2 = False
USE_PIANO_2 = False
USE_MORSE_2 = False

# Background color: True = black, False = white.
# Default: False
BLACK_BACKGROUND = False

# Begin in full screen mode?
# Setting this to False will begin in windowed mode.
# Default: False
WINDOW_FULLSCREEN = False

# Window size in windowed mode.
# Minimum recommended values: width = 800, height = 600
WINDOW_WIDTH = 912
WINDOW_HEIGHT = 684

# Skip title screen?
SKIP_TITLE_SCREEN = False

# Display feedback of correct/incorrect input?
# Default: True
SHOW_FEEDBACK = True

# Hide text during game? (this can be toggled in-game by pressing F8)
# Default: False
HIDE_TEXT = False

# Expand the field (squares) to fill the entire height of the screen?
# Note: this should only be used with HIDE_TEXT = True.
FIELD_EXPAND = False

# Show grid lines and crosshairs?
GRIDLINES = True
CROSSHAIRS = True

# Set the color of the square in non-Color N-Back modes.
# This also affects Dual Combination N-Back and Arithmetic N-Back.
# 1 = blue, 2 = cyan, 3 = green, 4 = grey,
# 5 = magenta, 6 = red, 7 = white, 8 = yellow
# Default: 1
VISUAL_COLOR = 1

# Specify image sets here. This is a list of subfolders in the res\sprites\
# folder which may be selected in Image mode.
# The first item in the list is the default which is loaded on startup.
IMAGE_SETS = ['polygons-basic', 'national-park-service', 'pentominoes',
              'tetrominoes-fixed', 'cartoon-faces']

# Animate squares?
ANIMATE_SQUARES = False

# Use the flat, single-color squares like in versions prior to 4.1?
# Also, use sharp corners or rounded corners?
OLD_STYLE_SQUARES = False
OLD_STYLE_SHARP_CORNERS = False

# Start in Manual mode?
# If this is False, the game will start in standard mode.
# Default: False
MANUAL = False
USE_MUSIC_MANUAL = False

# Starting game mode.
# Possible values:
#  2:'Dual',
#  3:'P-C-A',
#  4:'Dual Combination',
#  5:'Tri Combination',
#  6:'Quad Combination', 
#  7:'Arithmetic',
#  8:'Dual Arithmetic',
#  9:'Triple Arithmetic',
#  10:'Position',
#  11:'Sound',
#  20:'P-C',
#  21:'P-I',
#  22:'C-A',
#  23:'I-A',
#  24:'C-I',
#  25:'P-C-I',
#  26:'P-I-A',
#  27:'C-I-A',
#  28:'Quad',
#  100:'A-A',
#  101:'P-A-A',
#  102:'C-A-A',
#  103:'I-A-A',
#  104:'P-C-A-A',
#  105:'P-I-A-A',
#  106:'C-I-A-A',
#  107:'P-C-I-A-A' (Quintuple)
# Note: if JAEGGI_MODE is True, only Dual N-Back will be available.
# Default: 2
GAME_MODE = 2

# Default starting n-back levels.
# must be greater than or equal to 1.
# Look above to find the corresponding mode number.
BACK_2 = 2
BACK_3 = 2
BACK_4 = 1
BACK_5 = 1
BACK_6 = 1
BACK_7 = 1
BACK_8 = 1
BACK_9 = 1
BACK_10 = 2
BACK_11 = 2
BACK_20 = 2
BACK_21 = 2
BACK_22 = 2
BACK_23 = 2
BACK_24 = 2
BACK_25 = 2
BACK_26 = 2
BACK_27 = 2
BACK_28 = 2
BACK_100 = 2
BACK_101 = 2
BACK_102 = 2
BACK_103 = 2
BACK_104 = 2
BACK_105 = 2
BACK_106 = 2
BACK_107 = 2

# Use Variable N-Back by default?
# 0 = static n-back (default)
# 1 = variable n-back
VARIABLE_NBACK = 0

# Number of 0.1 second intervals per trial.
# Must be greater than or equal to 4 (ie, 1 second)
# Look above to find the corresponding mode number.
# Default: 30 (40 for the Arithmetic modes)
TICKS_2 = 30
TICKS_3 = 30
TICKS_4 = 30
TICKS_5 = 30
TICKS_6 = 30
TICKS_7 = 40
TICKS_8 = 40
TICKS_9 = 40
TICKS_10 = 30
TICKS_11 = 30
TICKS_20 = 30
TICKS_21 = 30
TICKS_22 = 30
TICKS_23 = 30
TICKS_24 = 30
TICKS_25 = 30
TICKS_26 = 30
TICKS_27 = 30
TICKS_28 = 30
TICKS_100 = 30
TICKS_101 = 30
TICKS_102 = 30
TICKS_103 = 30
TICKS_104 = 30
TICKS_105 = 30
TICKS_106 = 30
TICKS_107 = 30

# The number of trials per session equals
# NUM_TRIALS + NUM_TRIALS_FACTOR * n ^ NUM_TRIALS_EXPONENT,
# where n is the current n-back level.

# Default base number of trials per session.
# Must be greater than or equal to 1.
# Default: 20
NUM_TRIALS = 20

NUM_TRIALS_FACTOR = 1
NUM_TRIALS_EXPONENT = 2

# Thresholds for n-back level advancing & fallback.
# Values are 0-100.
# Set THRESHOLD_ADVANCE to 101 to disable automatic level advance.
# Set THRESHOLD_FALLBACK to 0 to disable fallback.
# FALLBACK_SESSIONS controls the number of sessions below
#    the fallback threshold that will trigger a level decrease.
# Note: in Jaeggi mode, only JAEGGI_ADVANCE and JAEGGI_FALLBACK
#    are used.
# Defaults: 80, 50, 3, 90, 75
THRESHOLD_ADVANCE = 80
THRESHOLD_FALLBACK = 50
THRESHOLD_FALLBACK_SESSIONS = 3
JAEGGI_ADVANCE = 90
JAEGGI_FALLBACK = 75

# Music/SFX options.
# Volumes are from 0.0 (silent) to 1.0 (full)
# Defaults: True, True, 1.0, 1.0
USE_MUSIC = True
USE_APPLAUSE = True
MUSIC_VOLUME = 1.0
SFX_VOLUME = 1.0

# Specify an alternate stats file.
# Default: stats.txt
STATSFILE = stats.txt

# Specify the hour the stats will roll over to a new day [0-23]
ROLLOVER_HOUR = 4

# Version check on startup (http protocol)?
# Default: True
VERSION_CHECK_ON_STARTUP = True

# The chance that a match will be generated by force, in addition to the
# inherent 1/8 chance. Setting this to 1 will guarantee at least one match
# each trial (and will cause some repetitive sequences to be generated).
# The value must be a decimal from 0 to 1
# Increasing this value will make the n-back task significantly easier.
# Note: this option has no effect in Jaeggi mode.
# Default: 0.25
CHANCE_OF_GUARANTEED_MATCH = 0.25

# Arithmetic mode settings.
ARITHMETIC_MAX_NUMBER = 12
ARITHMETIC_USE_NEGATIVES = False
ARITHMETIC_USE_ADDITION = True
ARITHMETIC_USE_SUBTRACTION = True
ARITHMETIC_USE_MULTIPLICATION = True
ARITHMETIC_USE_DIVISION = True
ARITHMETIC_ACCEPTABLE_DECIMALS = ['0.1', '0.2', '0.3', '0.4', '0.5', '0.6',
    '0.7', '0.8', '0.9', '0.125', '0.25', '0.375', '0.625', '0.75', '0.875',
    '0.15', '0.35', '0.45', '0.55', '0.65', '0.85', '0.95',]

# Colors for the color n-back task
# format: (red, green, blue, 255)
# Note: Changing these colors will have no effect in Dual or
#   Triple N-Back unless OLD_STYLE_SQUARES is set to True. 
# the _BLK colors are used when BLACK_BACKGROUND is set to True.
COLOR_1 = (0, 0, 255, 255)
COLOR_2 = (0, 255, 255, 255)
COLOR_3 = (0, 255, 0, 255)
COLOR_4 = (48, 48, 48, 255)
COLOR_4_BLK = (255, 255, 255, 255)
COLOR_5 = (255, 0, 255, 255)
COLOR_6 = (255, 0, 0, 255)
COLOR_7 = (208, 208, 208, 255)
COLOR_7_BLK = (64, 64, 64, 255)
COLOR_8 = (255, 255, 0, 255)

# text color
COLOR_TEXT = (0, 0, 0, 255)
COLOR_TEXT_BLK = (240, 240, 240, 255)

# input label color
COLOR_LABEL_CORRECT = (64, 255, 64, 255)
COLOR_LABEL_OOPS = (64, 64, 255, 255)
COLOR_LABEL_INCORRECT = (255, 64, 64, 255)


# Saccadic eye movement options.
# Delay = number of seconds to wait before switching the dot
# Repetitions = number of times to switch the dot
SACCADIC_DELAY = 0.5
SACCADIC_REPETITIONS = 60

######################################################################
# Keyboard definitions.
# The following keys cannot be used: ESC, X, P, F8, F10.
# Look up the key codes here:
# http://pyglet.org/doc/api/pyglet.window.key-module.html
######################################################################

# These are used in Dual N-Back, the default game mode.
# Position match. Default: 97 (A)
KEY_POSITION = 97
# Sound match. Default: 108 (L)
KEY_AUDIO = 108

# Sound2 match. Default: 59 (Semicolon ;)
KEY_AUDIO2 = 59

# Color match. Default: 102 (F)
KEY_COLOR = 102
# Image match. Default: 106 (J)
KEY_IMAGE = 106

# These are used in the Combination N-Back modes.
# Visual & n-visual match. Default: 115 (S)
KEY_VISVIS = 115
# Visual & n-audio match. Default: 100 (D)
KEY_VISAUDIO = 100
# Sound & n-visual match. Default: 106 (J)
KEY_AUDIOVIS = 106

######################################################################
# This is the end of the configuration file.
######################################################################
"""

def dump_pyglet_info():
    from pyglet import info
    sys.stdout = open(os.path.join(get_data_dir(), 'dump.txt'), 'w')
    info.dump()
    sys.stdout.close()
    window.on_close()

# parse config file & command line options
try:
    sys.argv[sys.argv.index('--vsync')]
    VSYNC = True
except:
    pass
try:
    sys.argv[sys.argv.index('--dump')]
    dump_pyglet_info()
except:
    pass
try: CONFIGFILE = sys.argv[sys.argv.index('--configfile') + 1]
except:
    pass

if CLINICAL_MODE and CONFIGFILE == 'config.ini':
    pass
else:
    if not os.path.isfile(os.path.join(get_data_dir(), CONFIGFILE)):
        newconfigfile = open(os.path.join(os.path.join(get_data_dir(), CONFIGFILE)), 'w')
        newconfigfile.write(CONFIGFILE_DEFAULT_CONTENTS)
        newconfigfile.close()
        
    # The following is a routine to overwrite older config files with the new one.
    oldconfigfile = open(os.path.join(os.path.join(get_data_dir(), CONFIGFILE)), 'r+')
    while oldconfigfile:
        line = oldconfigfile.readline()
        if line == '': # EOF reached. string 'generated by Brain Workshop' not found
            oldconfigfile.seek(0)
            oldconfigfile.truncate(0)
            oldconfigfile.write(CONFIGFILE_DEFAULT_CONTENTS)
            break
        if line.find('generated by Brain Workshop') > -1:
            splitline = line.split()
            version = float(splitline[5])
            if version < CONFIG_OVERWRITE_IF_OLDER_THAN:
                oldconfigfile.seek(0)
                oldconfigfile.truncate(0)
                oldconfigfile.write(CONFIGFILE_DEFAULT_CONTENTS)
            break
    oldconfigfile.close()
    
    try:
        config = ConfigParser.ConfigParser()
        config.read(os.path.join(get_data_dir(), CONFIGFILE))
    except:
        if CONFIGFILE != 'config.ini':
            quit_with_error('Unable to load config file: %s' %
                             os.path.join(get_data_dir(), CONFIGFILE))

defaultconfig = ConfigParser.ConfigParser() 
defaultconfig.readfp(StringIO.StringIO(CONFIGFILE_DEFAULT_CONTENTS))

def try_eval(text):  # this is a one-use function for config parsing
    try:  return eval(text)
    except: return text
    
if CLINICAL_MODE and CONFIGFILE == 'config.ini': configs = (defaultconfig,)
else: configs = (defaultconfig, config)

for cfg in configs: # load defaultconfig first, in case of incomplete user's config.ini
    config_items = [(k.upper(), try_eval(v)) for k, v in cfg.items('DEFAULT')]
    for item in config_items:
        exec "%s = item[1]" % item[0]
    del cfg
del configs, config_items, try_eval

try: STATSFILE = sys.argv[sys.argv.index('--statsfile') + 1]
except:
    pass

if CLINICAL_MODE:
    JAEGGI_INTERFACE_DEFAULT_SCORING = False
    JAEGGI_MODE = True
    JAEGGI_FORCE_OPTIONS = True
    JAEGGI_FORCE_OPTIONS_ADDITIONAL = True
    SKIP_TITLE_SCREEN = True
    USE_MUSIC = False
elif JAEGGI_INTERFACE_DEFAULT_SCORING:
    ANIMATE_SQUARES = False
    OLD_STYLE_SQUARES = True
    OLD_STYLE_SHARP_CORNERS = True
    GRIDLINES = False
    CROSSHAIRS = True
    SHOW_FEEDBACK = False
    BLACK_BACKGROUND = True
    WINDOW_FULLSCREEN = True
    HIDE_TEXT = True
    FIELD_EXPAND = True
    
if JAEGGI_MODE and not JAEGGI_INTERFACE_DEFAULT_SCORING:
    GAME_MODE = 2
    VARIABLE_NBACK = 0
    if JAEGGI_FORCE_OPTIONS:
        USE_LETTERS = True
        USE_NUMBERS = False
        USE_NATO = False
        USE_PIANO = False
        USE_MORSE = False
        ANIMATE_SQUARES = False
        OLD_STYLE_SQUARES = True
        OLD_STYLE_SHARP_CORNERS = True
        GRIDLINES = False
        CROSSHAIRS = True
        SHOW_FEEDBACK = False
        THRESHOLD_FALLBACK_SESSIONS = 1
        NUM_TRIALS_FACTOR = 1
        NUM_TRIALS_EXPONENT = 1
    if JAEGGI_FORCE_OPTIONS_ADDITIONAL:
        BLACK_BACKGROUND = True
        WINDOW_FULLSCREEN = True
        HIDE_TEXT = True
        FIELD_EXPAND = True

if BLACK_BACKGROUND:
    COLOR_TEXT = COLOR_TEXT_BLK
        
def get_threshold_advance():
    if JAEGGI_MODE:
        return JAEGGI_ADVANCE
    return THRESHOLD_ADVANCE
def get_threshold_fallback():
    if JAEGGI_MODE:
        return JAEGGI_FALLBACK
    return THRESHOLD_FALLBACK

# this function checks if a new update for Brain Workshop is available.
update_available = False
update_version = Decimal(0)
def update_check():
    global update_available
    global update_version
    socket.setdefaulttimeout(TIMEOUT_SILENT)
    req = urllib2.Request(WEB_VERSION_CHECK)
    try:
        response = urllib2.urlopen(req)
        version = Decimal(response.readline())
    except:
        return
    if version > Decimal(VERSION):
        update_available = True
        update_version = version

if VERSION_CHECK_ON_STARTUP and not CLINICAL_MODE:
    update_check()

try:
    # workaround for pyglet.gl.ContextException error on certain video cards.
    os.environ["PYGLET_SHADOW_WINDOW"]="0"
    # import pyglet
    import pyglet
    from pyglet.gl import *
    if NOVBO: pyglet.options['graphics_vbo'] = False
    from pyglet.window import key
except:
    quit_with_error('Error: unable to load pyglet.' +
                    'If you already installed pyglet, please ensure ctypes is installed.',
                    'Please visit %s' % WEB_PYGLET_DOWNLOAD)
try:
    pyglet.options['audio'] = ('directsound', 'openal', 'alsa', )
    # use in pyglet 1.2: pyglet.options['audio'] = ('directsound', 'pulse', 'openal', )
    import pyglet.media
except:
    quit_with_error('No suitable audio driver could be loaded.')

try:
    from pyglet.media import avbin
    if pyglet.version >= '1.2':  # temporary workaround for defect in pyglet svn 2445
        pyglet.media.have_avbin = True
except:
    USE_MUSIC = False
    if pyglet.version >= '1.2':  
        pyglet.media.have_avbin = False
    print 'AVBin not detected. Music disabled.'
    print 'Download AVBin from: http://code.google.com/p/avbin/'
        
# Initialize resources (sounds and images)
#
# --- BEGIN RESOURCE INITIALIZATION SECTION ----------------------------------
#

res_path = get_res_dir()
if not os.access(res_path, os.F_OK):
    quit_with_error('Error: the resource folder\n%s' % res_path + 
                    ' does not exist or is not readable.  Exiting', trace=False)

if pyglet.version < '1.1':
    quit_with_error('Error: pyglet 1.1 or greater is required.\n' + 
                    'You probably have an older version of pyglet installed.\n' +
                    'Please visit %s' % WEB_PYGLET_DOWNLOAD, trace=False)

supportedtypes = {'sounds' :['wav'],
                  'music'  :['wav', 'ogg', 'mp3', 'aac', 'mp2', 'ac3', 'm4a', 'mp2'], # what else?
                  'sprites':['png', 'jpg', 'bmp']}

if pyglet.media.have_avbin: supportedtypes['sounds'] = supportedtypes['music']
elif USE_MUSIC:             supportedtypes['music'] = supportedtypes['sounds']
else:                       del supportedtypes['music']

supportedtypes['misc'] = supportedtypes['sounds'] + supportedtypes['sprites']

resourcepaths = {}
for restype in supportedtypes.keys():
    res_sets = {}
    for folder in os.listdir(os.path.join(res_path, restype)):
        contents = []
        if os.path.isdir(os.path.join(res_path, restype, folder)):
            contents = [os.path.join(res_path, restype, folder, obj)
                          for obj in os.listdir(os.path.join(res_path, restype, folder))
                                  if obj[-3:] in supportedtypes[restype]]
            contents.sort()
        if contents: res_sets[folder] = contents
    if res_sets: resourcepaths[restype] = res_sets

sounds = {}
for k in resourcepaths['sounds'].keys():
    sounds[k] = {}
    for f in resourcepaths['sounds'][k]:
        sounds[k][os.path.basename(f).split('.')[0]] = pyglet.media.load(f, streaming=False)

sound = sounds['letters'] # is this obsolete yet?
    
if USE_APPLAUSE:
    applausesounds = [pyglet.media.load(soundfile, streaming=False)
                     for soundfile in resourcepaths['misc']['applause']]

applauseplayer = pyglet.media.ManagedSoundPlayer()
musicplayer = pyglet.media.ManagedSoundPlayer()

def sound_stop():
    global applauseplayer
    global musicplayer
    musicplayer.volume = 0
    applauseplayer.volume = 0

def fade_out(dt):
    global applauseplayer
    global musicplayer

    if musicplayer.volume > 0:
        if musicplayer.volume <= 0.1:
            musicplayer.volume -= 0.02
        else: musicplayer.volume -= 0.1
        if musicplayer.volume <= 0.02:
            musicplayer.volume = 0
    if applauseplayer.volume > 0:
        if applauseplayer.volume <= 0.1:
            applauseplayer.volume -= 0.02
        else: applauseplayer.volume -= 0.1
        if applauseplayer.volume <= 0.02:
            applauseplayer.volume = 0

    if (applauseplayer.volume == 0 and musicplayer.volume == 0) or mode.trial_number == 3:
        pyglet.clock.unschedule(fade_out)
        
        
#
# --- END RESOURCE INITIALIZATION SECTION ----------------------------------
#
    
    
# The colors of the squares in Triple N-Back mode are defined here.
# Color 1 is used in Dual N-Back mode.
def get_color(color):
    if color in (4, 7) and BLACK_BACKGROUND:
        return eval('COLOR_%i_BLK' % color)
    return eval('COLOR_%i' % color)

# set the input text label size
def input_label_size():
    m = mode.mode
    if m in (2, 3, 7, 8, 9, 10, 11, 20, 21, 22, 23, 24, 25, 26, 27, 28):
        return 16
    if m in (4,):
        return 14
    if m in (5,):
        return 13
    if m in (6,):
        return 11
    if m in (100, 101, 102, 103, 104, 105, 106, 107):
        return 16

def default_nback_mode(mode):
    return eval('BACK_%i' % mode)

def default_ticks(mode):
    return eval('TICKS_%i' % mode)        

#Create the game window
caption = []
if CLINICAL_MODE:
    caption.append('BW-Clinical ')
else:
    caption.append('Brain Workshop ')
caption.append(VERSION)
if STATSFILE != 'stats.txt':
    caption.append(' - ')
    caption.append(STATSFILE)
if WINDOW_FULLSCREEN:
    style = pyglet.window.Window.WINDOW_STYLE_BORDERLESS
else:
    style = pyglet.window.Window.WINDOW_STYLE_DEFAULT
     
#display = pyglet.window.get_platform().get_default_display() 
#screen = display.get_default_screen() 
#template_config = Config(double_buffer=True, sample_buffers=True, samples=4) 
#try: 
    #config = screen.get_best_config(template_config) 
#except pyglet.window.NoSuchConfigException: 
    ## Rats. No antialiasing. 
    #config = screen.get_best_config(Config(double_buffer=True)) 

class MyWindow(pyglet.window.Window):
    def on_key_press(self, symbol, modifiers):
        pass
    def on_key_release(self, symbol, modifiers):
        pass
    
window = MyWindow(WINDOW_WIDTH, WINDOW_HEIGHT, caption=''.join(caption), style=style, vsync=VSYNC)
if sys.platform == 'darwin': # and WINDOW_FULLSCREEN:
    window.set_exclusive_keyboard()
if sys.platform == 'linux2':
    window.set_icon(pyglet.image.load(resourcepaths['misc']['brain'][0]))

# set the background color of the window
if BLACK_BACKGROUND:
    glClearColor(0, 0, 0, 1)
else:
    glClearColor(1, 1, 1, 1)
if WINDOW_FULLSCREEN:
    window.maximize()
    window.set_mouse_visible(False)

# All changeable game state variables are located in an instance of the Mode class
class Mode:
    def __init__(self):
        self.mode = GAME_MODE
        self.back = default_nback_mode(self.mode)
        self.ticks_per_trial = default_ticks(self.mode)
        self.num_trials = NUM_TRIALS
        self.num_trials_factor = NUM_TRIALS_FACTOR
        self.num_trials_exponent = NUM_TRIALS_EXPONENT
        self.num_trials_total = self.num_trials + self.num_trials_factor * \
            self.back ** self.num_trials_exponent

        self.short_mode_names = {2:'D',
                                 3:'PCA',
                                 4:'DC',
                                 5:'TC',
                                 6:'QC',
                                 7:'A', 
                                 8:'DA',
                                 9:'TA',
                                 10:'Po',
                                 11:'Au',
                                 20:'PC',
                                 21:'PI',
                                 22:'CA',
                                 23:'IA',
                                 24:'CI',
                                 25:'PCI',
                                 26:'PIA',
                                 27:'CIA',
                                 28:'Q',
                                 100:'AA',
                                 101:'PAA',
                                 102:'CAA',
                                 103:'IAA',
                                 104:'PCAA',
                                 105:'PIAA',
                                 106:'CIAA',
                                 107:'PCIAA'
                                 }
        
        self.long_mode_names =  {2:'Dual',
                                 3:'P-C-A',
                                 4:'Dual Combination',
                                 5:'Tri Combination',
                                 6:'Quad Combination', 
                                 7:'Arithmetic',
                                 8:'Dual Arithmetic',
                                 9:'Triple Arithmetic',
                                 10:'Position',
                                 11:'Sound',
                                 20:'P-C',
                                 21:'P-I',
                                 22:'C-A',
                                 23:'I-A',
                                 24:'C-I',
                                 25:'P-C-I',
                                 26:'P-I-A',
                                 27:'C-I-A',
                                 28:'Quad',
                                 100:'A-A',
                                 101:'P-A-A',
                                 102:'C-A-A',
                                 103:'I-A-A',
                                 104:'P-C-A-A',
                                 105:'P-I-A-A',
                                 106:'C-I-A-A',
                                 107:'P-C-I-A-A'
                                 }
        
        self.modalities = { 2:['position', 'audio'],
                            3:['position', 'color', 'audio'],
                            4:['visvis', 'visaudio', 'audiovis', 'audio'],
                            5:['position', 'visvis', 'visaudio', 'audiovis', 'audio'],
                            6:['position', 'visvis', 'visaudio', 'color', 'audiovis', 'audio'],
                            7:['arithmetic'],
                            8:['position', 'arithmetic'],
                            9:['position', 'color', 'arithmetic'],
                            10:['position'],
                            11:['audio'],
                            20:['position', 'color'],
                            21:['position', 'image'],
                            22:['color', 'audio'],
                            23:['image', 'audio'],
                            24:['color', 'image'],
                            25:['position', 'color', 'image'],
                            26:['position', 'image', 'audio'],
                            27:['color', 'image', 'audio'],
                            28:['position', 'color', 'image', 'audio'],
                            
                            100:['audio', 'audio2'],
                            101:['position', 'audio', 'audio2'],
                            102:['color', 'audio', 'audio2'],
                            103:['image', 'audio', 'audio2'],
                            104:['position', 'color', 'audio', 'audio2'],
                            105:['position', 'image', 'audio', 'audio2'],
                            106:['color', 'image', 'audio', 'audio2'],
                            107:['position', 'color', 'image', 'audio', 'audio2']
                            }
        
        self.variable_list = []
        
        self.manual = MANUAL
        if not self.manual:
            self.enforce_standard_mode()
                    
        self.position_input = False
        self.color_input = False
        self.image_input = False
        self.visvis_input = False
        self.visaudio_input = False
        self.audiovis_input = False
        self.audio_input = False
        self.audio2_input = False
        
        self.hide_text = HIDE_TEXT
        
        self.current_position = 0
        self.current_color = 0
        self.current_vis = 0
        self.current_audio = 0
        self.current_audio2 = 0
        self.current_number = 0
        self.current_operation = 'none'
        
        self.started = False
        self.paused = False
        self.show_missed = False
        self.game_select = False
        self.image_select = False
        self.sound_select = False
        self.draw_graph = False
        self.saccadic = False
        if SKIP_TITLE_SCREEN:
            self.title_screen = False
        else:
            self.title_screen = True
        self.shrink_brain = False
        
        self.session_number = 0
        self.trial_number = 0
        self.tick = 0
        self.progress = 0
        
        self.sound_mode = 'none'
        self.sound2_mode = 'none'
        self.soundlist = []
        self.soundlist2 = []
        
        self.bt_sequence = []
        
    def enforce_standard_mode(self):
        self.back = default_nback_mode(self.mode)
        self.ticks_per_trial = default_ticks(self.mode)
        self.num_trials = NUM_TRIALS
        self.num_trials_factor = NUM_TRIALS_FACTOR
        self.num_trials_exponent = NUM_TRIALS_EXPONENT
        self.num_trials_total = self.num_trials + self.num_trials_factor * \
            self.back ** self.num_trials_exponent
        self.session_number = 0

    def short_name(self, mode=None, back=None):
        if mode == None: mode = self.mode
        if back == None: back = self.back
        return self.short_mode_names[mode] + str(back) + 'B'
    
# What follows are the classes which control all the text and graphics.
#
# --- BEGIN GRAPHICS SECTION ----------------------------------------------
#

class Graph:
    def __init__(self):
        self.graph = 2
        self.reset_dictionaries()
        self.reset_percents()
        self.batch = None

    def reset_dictionaries(self):
        self.dictionaries = dict([(i, {}) for i in mode.modalities])
        
    def reset_percents(self):
        self.percents = dict([(k, dict([(i, []) for i in v])) for k,v in mode.modalities.items()])

    def next_mode(self):
        if self.graph == 28:
            self.graph = 100
        elif self.graph == 107:
            self.graph = 2
        elif self.graph == 11:
            self.graph = 20
        else: self.graph += 1
        self.batch = None
        
    def parse_stats(self):
        self.batch = None
        self.reset_dictionaries()
        self.reset_percents()
        ind = {'date':0, 'modename':1, 'percent':2, 'mode':3, 'n':4, 'ticks':5,
               'trials':6, 'manual':7, 'session':8, 'position':9, 'audio':10,
               'color':11, 'visvis':12, 'audiovis':13, 'arithmetic':14, 'image':15, 'visaudio':16, 'audio2':17}
                    
        if os.path.isfile(os.path.join(get_data_dir(), STATSFILE)):
            try:
                statsfile_path = os.path.join(get_data_dir(), STATSFILE)
                statsfile = open(statsfile_path, 'r')
                for line in statsfile:
                    if line == '': continue
                    if line == '\n': continue
                    datestamp = date(int(line[:4]), int(line[5:7]), int(line[8:10]))
                    hour = int(line[11:13])
                    if hour < ROLLOVER_HOUR:
                        datestamp = date.fromordinal(datestamp.toordinal() - 1)
                    if line.find('\t') >= 0:
                        separator = '\t'
                    else: separator = ','
                    newline = line.split(separator)
                    try: 
                        if int(newline[7]) != 0: # only consider standard mode
                            continue
                    except:
                        continue
                    newmode = int(newline[3])
                    newback = int(newline[4])
                    newpercent = int(newline[2])
                    dictionary = self.dictionaries[newmode]
                    if datestamp not in dictionary:
                        dictionary[datestamp] = []
                    dictionary[datestamp].append(newback)
                    
                    while len(newline) < 18:
                        newline.append('0') # make it work for image mode, missing visaudio and audio2
                    if len(newline) >= 16:
                        for m in mode.modalities[newmode]:
                            self.percents[newmode][m].append(int(newline[ind[m]]))
                        
                statsfile.close()
            except:
                quit_with_error('Error parsing stats file\n %s' % 
                                os.path.join(get_data_dir(), STATSFILE),
                                'Please fix, delete or rename the stats file.')

            for dictionary in self.dictionaries.values():
                for datestamp in dictionary.keys():
                    average = 0.0
                    max = 0.0
                    numentries = 0
                    for entry in dictionary[datestamp]:
                        average += entry
                        if entry > max:
                            max = entry
                        numentries += 1
                    dictionary[datestamp] = (average / numentries, max)
                    
            for game in self.percents:
                for category in self.percents[game]:
                    summation = 0
                    count = 0
                    for index in range(0, len(self.percents[game][category])):
                        if index < len(self.percents[game][category]) - 50:
                            continue
                        count += 1
                        summation += self.percents[game][category][index]
                    if count == 0:
                        average = 0
                    else:
                        average = int(summation / count)
                    self.percents[game][category].append(average)
                                    
                        
    #def export_data(self):       
        #dictionary = {}
        #for x in self.dictionaries: # cycle through game modes
            #chartfile_name = CHARTFILE[x]
            #dictionary = self.dictionaries[x]
            #output = ['Date\t%s N-Back Average\n' % mode.long_mode_names[x]]
            
            #keyslist = dictionary.keys()
            #keyslist.sort()
            #if len(keyslist) == 0: continue
            #for datestamp in keyslist:
                #if dictionary[datestamp] == (-1, -1):
                    #continue
                #output.append(str(datestamp))
                #output.append('\t')
                #output.append(str(dictionary[datestamp]))
                #output.append('\n')
        
            #try:
                #chartfile_path = os.path.join(get_data_dir(), chartfile_name)
                #chartfile = open(chartfile_path, 'w')
                #chartfile.write(''.join(output))
                #chartfile.close()
                            
            #except:
                #quit_with_error('Error writing chart file:\n%s' %
                                #os.path.join(get_data_dir(), chartfile_name))
                
    
    def draw(self):
        if not self.batch:
            self.create_batch()
        else:
            self.batch.draw()

    def create_batch(self):
        self.batch = pyglet.graphics.Batch()
        
        linecolor = (0, 0, 255)
        linecolor2 = (255, 0, 0)
        if BLACK_BACKGROUND:
            axiscolor = (96, 96, 96)
            minorcolor = (64, 64, 64)
        else: 
            axiscolor = (160, 160, 160)
            minorcolor = (224, 224, 224)
        
        x_label_width = 20
        y_marking_interval = 0.25

        height = int(window.height * 0.625)
        width = int(window.width * 0.625)
        center_x = window.width // 2
        center_y = window.height // 2 + 20
        left = center_x - width // 2
        right = center_x + width // 2
        top = center_y + height // 2
        bottom = center_y - height // 2
        
        dictionary = self.dictionaries[self.graph]
        graph_title = mode.long_mode_names[self.graph] + ' N-Back'
        
        self.batch.add(3, GL_LINE_STRIP, 
            pyglet.graphics.OrderedGroup(order=1), ('v2i', (
            left, top,
            left, bottom,
            right, bottom)), ('c3B', axiscolor * 3))
        
        pyglet.text.Label(
            'G: Return to Main Screen\n\nN: Next Game Type',
            batch=self.batch,
            multiline = True, width = 300,
            font_size=9,
            color=COLOR_TEXT,
            x=10, y=window.height - 10,
            anchor_x='left', anchor_y='top')

        pyglet.text.Label(graph_title,
            batch=self.batch,
            font_size = 18, bold=True, color=COLOR_TEXT,
            x = center_x, y = top + 60,
            anchor_x = 'center', anchor_y = 'center')
        
        pyglet.text.Label('Date',
            batch=self.batch,
            font_size = 12, bold=True, color=COLOR_TEXT,
            x = center_x, y = bottom - 80,
            anchor_x = 'center', anchor_y = 'center')

        pyglet.text.Label('Maximum', width=1,
            batch=self.batch,
            font_size = 12, bold=True, color=linecolor2+(255,),
            x = left - 60, y = center_y + 50,
            anchor_x = 'right', anchor_y = 'center')
        
        pyglet.text.Label('Average', width=1,
            batch=self.batch,
            font_size = 12, bold=True, color=linecolor+(255,),
            x = left - 60, y = center_y + 25,
            anchor_x = 'right', anchor_y = 'center')

        pyglet.text.Label('N-Back', width=1,
        batch=self.batch,
        font_size = 12, bold=True, color=COLOR_TEXT,
        x = left - 60, y = center_y,
        anchor_x = 'right', anchor_y = 'center')
                
        dates = dictionary.keys()
        dates.sort()
        if len(dates) < 2:
            pyglet.text.Label('Insufficient data: two days needed',
                batch=self.batch,
                font_size = 12, bold = True, color = axiscolor + (255,),
                x = center_x, y = center_y,
                anchor_x = 'center', anchor_y = 'center')
            return
        
        ymin = 100000.0
        ymax = 0.0
        for entry in dates:
            if dictionary[entry] == (-1, -1):
                continue
            if dictionary[entry][0] < ymin:
                ymin = dictionary[entry][0]
            if dictionary[entry][1] > ymax:
                ymax = dictionary[entry][1]
        if ymin == ymax:
            ymin = 0
        
        pyglet.clock.tick(poll=True) # Prevent music skipping 1

        ymin = int(math.floor(ymin * 4))/4.
        ymax = int(math.ceil(ymax * 4))/4.
        
        # remove these two lines to revert to the old behaviour
        ymin = 1.0
        ymax += 0.25
        
        # add intermediate days
        z = 0
        while z < len(dates) - 1:
            if dates[z+1].toordinal() > dates[z].toordinal() + 1:
                newdate = date.fromordinal(dates[z].toordinal() + 1)
                dates.insert(z+1, newdate)
                dictionary[newdate] = (-1, -1)
            z += 1
        
        avgpoints = []
        maxpoints = []
        
        xinterval = width / (float(len(dates) - 1))
        skip_x = int(math.floor(x_label_width / xinterval))

        for index in range(len(dates)):
            x = int(xinterval * index + left)
            if dictionary[dates[index]][0] != -1:
                avgpoints.extend([x, int((dictionary[dates[index]][0] - ymin)/(ymax - ymin) * height + bottom)])
                maxpoints.extend([x, int((dictionary[dates[index]][1] - ymin)/(ymax - ymin) * height + bottom)])
            datestring = str(dates[index])[2:]
            datestring = datestring.replace('-', '\n')
            if not index % (skip_x + 1):
                pyglet.text.Label(datestring, multiline=True, width=12,
                    batch=self.batch,
                    font_size=8, bold=False, color=COLOR_TEXT,
                    x=x, y=bottom - 15,
                    anchor_x='center', anchor_y='top')
                self.batch.add(2, GL_LINES, 
                    pyglet.graphics.OrderedGroup(order=0), ('v2i', (
                    x, bottom,
                    x, top)), ('c3B', minorcolor * 2))
                self.batch.add(2, GL_LINES, 
                    pyglet.graphics.OrderedGroup(order=1), ('v2i', (
                    x, bottom - 10,
                    x, bottom)), ('c3B', axiscolor * 2))
        
        pyglet.clock.tick(poll=True) # Prevent music skipping 2
        
        y_marking = ymin
        while y_marking <= ymax:
            y = int((y_marking - ymin)/(ymax - ymin) * height + bottom)
            pyglet.text.Label(str(round(y_marking, 2)),
                batch=self.batch,
                font_size = 10, bold=False, color=COLOR_TEXT,
                x = left - 30, y = y + 1,
                anchor_x = 'center', anchor_y = 'center')
            self.batch.add(2, GL_LINES, 
                pyglet.graphics.OrderedGroup(order=0), ('v2i', (
                left, y,
                right, y)), ('c3B', minorcolor * 2))
            self.batch.add(2, GL_LINES, 
                pyglet.graphics.OrderedGroup(order=1), ('v2i', (
                left - 10, y,
                left, y)), ('c3B', axiscolor * 2))
            y_marking += y_marking_interval
        
        self.batch.add(len(avgpoints) // 2, GL_LINE_STRIP, 
            pyglet.graphics.OrderedGroup(order=2), ('v2i',
            avgpoints),
            ('c3B', linecolor * (len(avgpoints) // 2)))
        self.batch.add(len(maxpoints) // 2, GL_LINE_STRIP, 
            pyglet.graphics.OrderedGroup(order=3), ('v2i',
            maxpoints),
            ('c3B', linecolor2 * (len(maxpoints) // 2)))
  
        pyglet.clock.tick(poll=True) # Prevent music skipping 3

        radius = 1
        o = 4
        for index in range(0, len(avgpoints) // 2):
            x = avgpoints[index * 2]
            avg = avgpoints[index * 2 + 1]
            max = maxpoints[index * 2 + 1]
            # draw average
            self.batch.add(4, GL_POLYGON, 
                pyglet.graphics.OrderedGroup(order=o), ('v2i',
                (x - radius, avg - radius,
                 x - radius, avg + radius,
                 x + radius, avg + radius,
                 x + radius, avg - radius)),
                ('c3b', linecolor * 4))
            o += 1
            # draw maximum
            self.batch.add(4, GL_POLYGON, 
                pyglet.graphics.OrderedGroup(order=o), ('v2i',
                (x - radius, max - radius,
                 x - radius, max + radius,
                 x + radius, max + radius,
                 x + radius, max - radius)),
                ('c3b', linecolor2 * 4))
            o += 1
        
        pyglet.clock.tick(poll=True) # Prevent music skipping 4

        labelstrings = {'position':'Position: ','visvis':'Vis & nvis: ', 
                        'visaudio':'Vis & n-sound: ', 'color':'Color: ', 
                        'audiovis':'Sound & n-vis: ', 'audio':'Sound: ',
                        'arithmetic':'Arithmetic: ', 'image':'Image: ',
                        'audio2':'Sound2: '}       
        str_list = ['Last 50 rounds:   ']
        for m in mode.modalities[self.graph]:
            str_list.append(labelstrings[m] + '%i%% ' % self.percents[self.graph][m][-1]
                            + ' ' * (7-len(mode.modalities[self.graph])))
          
        pyglet.text.Label(''.join(str_list),
            batch=self.batch,
            font_size = 11, bold = False, color = COLOR_TEXT,
            x = window.width // 2, y = 20,
            anchor_x = 'center', anchor_y = 'center')                

class Menu:
    """
    Menu.__init__(self, options, title=''):
        
    A generic menu class.  The argument options is edited in-place.  Instancing
    the Menu displays the menu.  Menu will install its own event handlers for
    on_key_press, on_text, on_text_motion and on_draw, all of which 
    do not pass events to later handlers on the stack.  When the user presses 
    esc,  Menu pops its handlers off the stack.
    
    """
    titlesize = 18
    choicesize = 12
    
    def __init__(self, options, title=''):
        self.bgcolor = (255 * int(not BLACK_BACKGROUND), )*3
        self.textcolor = (0,0,0,255)#(255 * int(BLACK_BACKGROUND), )*3
        self.markercolors = (255, 0, 0, 0, 255, 0, 0, 0, 255) # self.textcolor*3
        self.pagesize = min(len(options), (window.height*7/10) / (self.choicesize*3/2))
        self.options = options
        self.disppos = 0  # which item in options is the first on the screen
        self.selpos = 0 
        self.batch = pyglet.graphics.Batch()
        self.title = pyglet.text.Label(title, font_size=self.titlesize,
            bold=True, color=self.textcolor, batch=self.batch,
            x=window.width/2, y=(window.height*9)/10,
            anchor_x='center', anchor_y='center')
        
        self.labels = [pyglet.text.Label('', font_size=self.choicesize,
            bold=False, color=self.textcolor, batch=self.batch,
            x=window.width/8, y=(window.height*8)/10 - i*(self.choicesize*3/2),
            anchor_x='left', anchor_y='center') for i in range(self.pagesize)]
        
        self.marker = self.batch.add(3, GL_POLYGON, None, ('v2i', (0,)*6,),
            ('c3b', self.markercolors))
            
        self.update_labels()

        window.push_handlers(self.on_key_press, self.on_text, 
                             self.on_text_motion, self.on_draw)
        
    def textify(self, x):
        if type(x) == bool:
            return x and 'Yes' or 'No'
        return str(x)

    def update_labels(self):
        for l in self.labels:   l.text = 'meow'
        
        markerpos = self.selpos - self.disppos                
        i = 0
        if not self.disppos == 0:
            self.labels[i].text = '...'
            i += 1
        ending = int(self.disppos + self.pagesize < len(self.options))
        while i < self.pagesize-ending and i+self.disppos < len(self.options):
            k,v = self.options.items()[i+self.disppos]
            self.labels[i].text = '%s:\t%s' % (str(k), self.textify(v))
            i += 1
        if ending:
            self.labels[i].text = '...'
        w, h, cs = window.width, window.height, self.choicesize
        self.marker.vertices = [w/10, (h*8)/10 - markerpos*(cs*3/2) + cs/2,
                                w/9,  (h*8)/10 - markerpos*(cs*3/2),
                                w/10, (h*8)/10 - markerpos*(cs*3/2) - cs/2]
        
    def move_selection(self, steps, relative=True):
        if relative:
            self.selpos += steps
        else:
            self.selpos = steps
        self.selpos = min(len(self.options)-1, max(0, self.selpos))
        if self.disppos >= self.selpos and not self.disppos == 0:
            self.disppos = max(0, selpos-1)
        if self.disppos <= self.selpos - self.pagesize \
          and not self.disppos == len(self.options) - self.pagesize:
            self.disppos = max(0, min(len(self.options), self.selpos+1) - self.pagesize)
        self.update_labels()
        
    def on_key_press(self, sym, mod):
        if sym == key.ESCAPE:
            self.close()
        elif sym in (key.RETURN, key.ENTER):
            self.select()
        return pyglet.event.EVENT_HANDLED
    
    def select(self):
        k = self.options.keys()[self.selpos]
        if type(self.options[k]) == bool:
            self.options[k] = not self.options[k]  # todo: other data types
        self.update_labels()
        
    def close(self):
        return window.pop_handlers()
    
    def on_text_motion(self, evt):
        if evt == key.MOTION_UP:            self.move_selection(steps=-1)
        if evt == key.MOTION_DOWN:          self.move_selection(steps=1)
        if evt == key.MOTION_NEXT_PAGE:     self.move_selection(steps=-self.pagesize)
        if evt == key.MOTION_PREVIOUS_PAGE: self.move_selection(steps=self.pagesize)
        return pyglet.event.EVENT_HANDLED
    
    def on_text(self, evt):
        return pyglet.event.EVENT_HANDLED # todo: entering values after select()
    
    def on_draw(self):
        window.clear()
        self.batch.draw()
        return pyglet.event.EVENT_HANDLED
        

class GameSelect:
    def __init__(self):
        
        self.label = pyglet.text.Label(
            '', multiline=True, width=380,
            font_size=14, bold=False, color=COLOR_TEXT,
            x=20, y=window.height - 50,
            anchor_x='left', anchor_y='top')
        self.label2 = pyglet.text.Label(
            '', multiline = True, width = 380,
            font_size=14, bold=False, color = COLOR_TEXT,
            x = window.width // 2, y = window.height - 50,
            anchor_x='left', anchor_y='top')
        
    def draw(self):
        str_list = []
        str_list.append('Type a number or letter choose the game mode.\n')
        str_list.append('\n\n')
        str_list.append('  0: Position N-Back\n')
        str_list.append('  1: Sound N-Back\n')
        str_list.append('\n')
        str_list.append('  2: Dual N-Back (default)\n')
        str_list.append('  3: Position - Color - Sound\n')
        str_list.append('\n')
        str_list.append('  4: Dual Combination N-Back\n')
        str_list.append('  5: Tri Combination N-Back\n')
        str_list.append('  6: Quad Combination N-Back\n')
        str_list.append('\n')
        str_list.append('  7: Arithmetic N-Back\n')
        str_list.append('  8: Dual Arithmetic N-Back\n')
        str_list.append('  9: Triple Arithmetic N-Back\n')
        str_list.append('\n')
        str_list.append('  V: Use Variable n-back levels?')
        if VARIABLE_NBACK == 1:
            str_list.append('   YES')
        elif VARIABLE_NBACK == 0:
            str_list.append('   NO')
        str_list.append('\n\n')
        str_list.append('  ESC: Cancel')
        
        str_list2 = []
        str_list2.append('\n\n\n\n')
        str_list2.append('  Q: Position - Color\n')
        str_list2.append('  W: Position - Image\n')
        str_list2.append('  E: Color - Sound\n')
        str_list2.append('  R: Image - Sound\n')
        str_list2.append('  T: Color - Image\n')
        str_list2.append('\n')
        str_list2.append('  Y: Position - Color - Image\n')
        str_list2.append('  U: Position - Image - Sound\n')
        str_list2.append('  I: Color - Image - Sound\n')
        str_list2.append('\n')
        str_list2.append('  O: Quad N-Back\n')
        str_list2.append('\n')
        str_list2.append('  A: Sound - Sound2\n')
        str_list2.append('  S: Position - Sound - Sound2\n')
        str_list2.append('  D: Color - Sound - Sound2\n')
        str_list2.append('  F: Image - Sound - Sound2\n')
        str_list2.append('  G: Position - Color - Sound - Sound2\n')
        str_list2.append('  H: Position - Image - Sound - Sound2\n')
        str_list2.append('  J: Color - Image - Sound - Sound2\n\n')
        str_list2.append('  K: Quintuple N-Back\n')
                

        self.label.text = ''.join(str_list)
        self.label2.text = ''.join(str_list2)
        
        self.label.draw()
        self.label2.draw()
        
class ImageSelect:
    def __init__(self):
        
        str_list = []
        str_list.append('Type a number to choose images for the Image n-back task.\n\n')
        
        for index in range(0, len(IMAGE_SETS)):
            if index > 9: break
            str_list.append('  ')
            str_list.append(str(index))
            str_list.append(': ')
            str_list.append(IMAGE_SETS[index])
            str_list.append('\n')
        
        self.label = pyglet.text.Label(
            ''.join(str_list), multiline = True, width = 450,
            font_size = 16, bold=False, color = COLOR_TEXT,
            x = window.width // 2, y = window.height - 50,
            anchor_x='center', anchor_y='top')
        
    def draw(self):
        self.label.draw()
            
class SoundSelect:
    def __init__(self):
                
        str_list = []
        str_list.append('Press a key to choose sounds for the Sound n-back tasks.\n\n')
        str_list.append('If multiple sounds are selected, one will be randomly chosen each session.\n')
        str_list.append('\n\n')
        
        self.label1 = pyglet.text.Label(
            ''.join(str_list), multiline = True, width = 700,
            font_size=14, bold=False, color = COLOR_TEXT,
            x = window.width // 2, y = window.height - 25,
            anchor_x='center', anchor_y='top')
        
        self.label2 = pyglet.text.Label(
            '', multiline = True, width = 700,
            font_size=14, bold=False, color = COLOR_TEXT,
            x = window.width // 2, y = window.height - 125,
            anchor_x='center', anchor_y='top')
        
    def draw(self):
                
        str_list = []
        str_list.append('Sound task:\n\n')
        
        if('audio2' in mode.modalities[mode.mode]):
            str_list.append('  L:  ')
            str_list.append(CHANNEL_AUDIO)
            str_list.append(' channel\n\n')
        
        if USE_LETTERS:
            str_list.append('Yes')
        else: str_list.append('No  ')
        str_list.append('  1:  Letters\n')
        if USE_NUMBERS:
            str_list.append('Yes')
        else: str_list.append('No  ')
        str_list.append('  2:  Numbers\n')
        if USE_NATO:
            str_list.append('Yes')
        else: str_list.append('No  ')
        str_list.append('  3:  NATO Phonetic Alphabet\n')
        if USE_PIANO:
            str_list.append('Yes')
        else: str_list.append('No  ')
        str_list.append('  4:  Piano Notes\n')
        if USE_MORSE:
            str_list.append('Yes')
        else: str_list.append('No  ')
        str_list.append('  5:  Morse Code\n')
        str_list.append('\n\n')
        
        if('audio2' in mode.modalities[mode.mode]):
            str_list.append('Sound2 task:\n\n')
            
            str_list.append('  ;:  ')
            str_list.append(CHANNEL_AUDIO2)
            str_list.append(' channel\n\n')
            
            if USE_LETTERS_2:
                str_list.append('Yes')
            else: str_list.append('No  ')
            str_list.append('  Q:  Letters\n')
            if USE_NUMBERS_2:
                str_list.append('Yes')
            else: str_list.append('No  ')
            str_list.append('  W:  Numbers\n')
            if USE_NATO_2:
                str_list.append('Yes')
            else: str_list.append('No  ')
            str_list.append('  E:  NATO Phonetic Alphabet\n')
            if USE_PIANO_2:
                str_list.append('Yes')
            else: str_list.append('No  ')
            str_list.append('  R:  Piano Notes\n')
            if USE_MORSE_2:
                str_list.append('Yes')
            else: str_list.append('No  ')
            str_list.append('  T:  Morse Code\n')
            str_list.append('\n\n')
        str_list.append('SPACE: Continue')
        
        self.label2.text = ''.join(str_list)
        
        self.label1.draw()
        self.label2.draw()

# this class controls the field.
# the field is the grid on which the squares appear
class Field:
    def __init__(self):
        if FIELD_EXPAND:
            self.size = int(window.height * 0.85)
        else: self.size = int(window.height * 0.625)
        if BLACK_BACKGROUND:
            self.color = (64, 64, 64)
        else: 
            self.color = (192, 192, 192)
        self.color4 = self.color * 4
        self.color8 = self.color * 8
        self.center_x = window.width // 2
        if FIELD_EXPAND:
            self.center_y = window.height // 2
        else: self.center_y = window.height // 2 + 20
        self.x1 = self.center_x - self.size/2
        self.x2 = self.center_x + self.size/2
        self.x3 = self.center_x - self.size/6
        self.x4 = self.center_x + self.size/6
        self.y1 = self.center_y - self.size/2
        self.y2 = self.center_y + self.size/2
        self.y3 = self.center_y - self.size/6
        self.y4 = self.center_y + self.size/6
        
        # add the inside lines
        if GRIDLINES:
            self.v_lines = batch.add(8, GL_LINES, None, ('v2i', (
                self.x1, self.y3,
                self.x2, self.y3,
                self.x1, self.y4,
                self.x2, self.y4,
                self.x3, self.y1,
                self.x3, self.y2,
                self.x4, self.y1,
                self.x4, self.y2)),
                      ('c3B', self.color8))
                
        self.crosshair_visible = False
        # initialize crosshair
        self.crosshair_update()
                
    # draw the target cross in the center
    def crosshair_update(self):
        if not CROSSHAIRS:
            return
        if (not mode.paused) and 'position' in mode.modalities[mode.mode] and not VARIABLE_NBACK: # and mode.mode != 12 and mode.mode != 13 and mode.mode != 14:
            if self.crosshair_visible: return
            else:
                self.v_crosshair = batch.add(4, GL_LINES, None, ('v2i', (
                    self.center_x - 8, self.center_y,
                    self.center_x + 8, self.center_y,
                    self.center_x, self.center_y - 8,
                    self.center_x, self.center_y + 8)), ('c3B', self.color4))
                self.crosshair_visible = True
        else:
            if self.crosshair_visible:
                self.v_crosshair.delete()
                self.crosshair_visible = False
            else: return


# this class controls the visual cues (colored squares).
class Visual:
    def __init__(self):
        self.visible = False
        self.label = pyglet.text.Label(
            '',
            font_size=field.size//6, bold=True,
            anchor_x='center', anchor_y='center', batch=batch)
        self.variable_label = pyglet.text.Label(
            '',
            font_size=field.size//6, bold=True,
            anchor_x='center', anchor_y='center', batch=batch)

        self.spr_square = [pyglet.sprite.Sprite(pyglet.image.load(path))
                              for path in resourcepaths['misc']['colored-squares']]
        self.spr_square_size = self.spr_square[0].width
        
        # load default image set
        self.load_set(0)
        
    def load_set(self, index):
        self.image_set = [pyglet.sprite.Sprite(pyglet.image.load(path))
                          for path in resourcepaths['sprites'][IMAGE_SETS[index]]]
        self.image_set_size = self.image_set[0].width
        
    def choose_random_images(self, number):
        self.images = random.sample(self.image_set, number)
        
    def spawn(self, position=0, color=1, vis=0, number=-1, operation='none', variable = 0):
        if ANIMATE_SQUARES:
            self.size_factor = 0.9375
        elif OLD_STYLE_SQUARES:
            self.size_factor = 0.9375
        else:
            self.size_factor = 1.0
        self.size = int(field.size / 3 * self.size_factor)
        self.position = position
        self.color = get_color(color)
        self.vis = vis
        
        self.center_x = field.center_x + (field.size / 3)*((position+1)%3 - 1) + (field.size / 3 - self.size)/2
        self.center_y = field.center_y + (field.size / 3)*((position/3+1)%3 - 1) + (field.size / 3 - self.size)/2
        
        if self.vis == 0:
            if OLD_STYLE_SQUARES:
                lx = self.center_x - self.size // 2 + 2
                rx = self.center_x + self.size // 2 - 2
                by = self.center_y - self.size // 2 + 2
                ty = self.center_y + self.size // 2 - 2
                cr = self.size // 5
                
                if OLD_STYLE_SHARP_CORNERS:
                    self.square = batch.add(4, GL_POLYGON, None, ('v2i', (
                        lx, by,
                        rx, by,
                        rx, ty,
                        lx, ty,)),
                        ('c4B', self.color * 4))
                else:
                    #rounded corners: bottom-left, bottom-right, top-right, top-left
                    x = ([lx + int(cr*(1-math.cos(math.radians(i)))) for i in range(0, 91, 10)] +
                         [rx - int(cr*(1-math.sin(math.radians(i)))) for i in range(0, 91, 10)] +
                         [rx - int(cr*(1-math.sin(math.radians(i)))) for i in range(90, -1, -10)] +
                         [lx + int(cr*(1-math.cos(math.radians(i)))) for i in range(90, -1, -10)])
                        
                    y = ([by + int(cr*(1-math.sin(math.radians(i)))) for i in range(0, 91, 10) + range(90, -1, -10)] +
                         [ty - int(cr*(1-math.sin(math.radians(i)))) for i in range(0, 91, 10) + range(90, -1, -10)])
                    xy = []
                    for a,b in zip(x,y): xy.extend((a, b))
                    
                    self.square = batch.add(40, GL_POLYGON, None, 
                                            ('v2i', xy), ('c4B', self.color * 40))
                
            else:
                # use sprite squares   
                self.square = self.spr_square[color-1]
                self.square.opacity = 255
                self.square.x = self.center_x - field.size // 6
                self.square.y = self.center_y - field.size // 6
                self.square.scale = 1.0 * self.size / self.spr_square_size
                self.square_size_scaled = self.square.width
                self.square.batch = batch
                
                # initiate square animation
                self.age = 0.0
                pyglet.clock.schedule_interval(visual.animate_square, 1/60.)
        
        elif mode.mode in (7, 8, 9): # display a number
            self.label.text = str(number)
            self.label.x = self.center_x
            self.label.y = self.center_y + 4
            self.label.color = self.color
        elif mode.mode in (4, 5, 6): # display a letter
            self.label.text = self.letters[vis - 1].upper()
            self.label.x = self.center_x
            self.label.y = self.center_y + 4
            self.label.color = self.color
        elif mode.mode in (21, 23, 24, 25, 26, 27, 28, 103, 105, 106, 107): # display a pictogram
            self.square = self.images[vis-1]
            self.square.opacity = 255
            self.square.color = self.color[:3]
            self.square.x = self.center_x - field.size // 6
            self.square.y = self.center_y - field.size // 6
            self.square.scale = 1.0 * self.size / self.image_set_size
            self.square_size_scaled = self.square.width
            self.square.batch = batch
            
            # initiate square animation
            self.age = 0.0
            #self.animate_square(0)
            pyglet.clock.schedule_interval(visual.animate_square, 1/60.)
            
        if variable > 0:
            # display variable n-back level
            self.variable_label.text = str(variable)

            if mode.mode == 4 or mode.mode == 7 or mode.mode == 11:
                self.variable_label.x = field.center_x
                self.variable_label.y = field.center_y - field.size//3 + 4
            else:
                self.variable_label.x = field.center_x
                self.variable_label.y = field.center_y + 4

            self.variable_label.color = self.color
        
        self.visible = True
        
    def animate_square(self, dt):
        self.age += dt
        if mode.paused: return
        if not ANIMATE_SQUARES: return
        
        # factors which affect animation
        scale_addition = dt / 8
        fade_begin_time = 0.4
        fade_end_time = 0.5
        fade_end_transparency = 1.0  # 1 = fully transparent, 0.5 = half transparent
    
        self.square.scale += scale_addition
        dx = (self.square.width - self.square_size_scaled) // 2
        self.square.x = self.center_x - field.size // 6 - dx
        self.square.y = self.center_y - field.size // 6 - dx
        
        if self.age > fade_begin_time:
            factor = (1.0 - fade_end_transparency * (self.age - fade_begin_time) / (fade_end_time - fade_begin_time))
            if factor > 1.0: factor = 1.0
            if factor < 0.0: factor = 0.0
            self.square.opacity = int(255 * factor)
    
    def hide(self):
        if self.visible:
            self.label.text = ''
            self.variable_label.text = ''
            if mode.mode in (21, 23, 24, 25, 26, 27, 28, 103, 105, 106, 107):
                self.square.batch = None
                pyglet.clock.unschedule(visual.animate_square)
            elif self.vis == 0:
                if OLD_STYLE_SQUARES:
                    self.square.delete()
                else:
                    self.square.batch = None
                    pyglet.clock.unschedule(visual.animate_square)
            self.visible = False
            
# Circles is the 3-strikes indicator in the top left corner of the screen.
class Circles:
    def __init__(self):
        self.y = window.height - 20
        self.start_x = 30
        self.radius = 8
        self.distance = 20
        if BLACK_BACKGROUND:
            self.not_activated = [64, 64, 64, 255]
        else:
            self.not_activated = [192, 192, 192, 255]
        self.activated = [64, 64, 255, 255]
        if BLACK_BACKGROUND:
            self.invisible = [0, 0, 0, 0]
        else:
            self.invisible = [255, 255, 255, 0]
        
        self.circle = []
        for index in range(0, THRESHOLD_FALLBACK_SESSIONS - 1):
            self.circle.append(batch.add(4, GL_QUADS, None, ('v2i', (
                self.start_x + self.distance * index - self.radius,
                self.y + self.radius,
                self.start_x + self.distance * index + self.radius,
                self.y + self.radius,
                self.start_x + self.distance * index + self.radius,
                self.y - self.radius,
                self.start_x + self.distance * index - self.radius,
                self.y - self.radius)),
                ('c4B', self.not_activated * 4)))
            
        self.update()
            
    def update(self):
        if mode.manual or mode.started or JAEGGI_MODE:
            for i in range(0, THRESHOLD_FALLBACK_SESSIONS - 1):
                self.circle[i].colors = (self.invisible * 4)
        else:
            for i in range(0, THRESHOLD_FALLBACK_SESSIONS - 1):
                self.circle[i].colors = (self.not_activated * 4)
            for i in range(0, mode.progress):
                self.circle[i].colors = (self.activated * 4)
            
        
# this is the update notification
class UpdateLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            multiline = True, width = field.size//3 - 4, halign='middle',
            font_size=11, bold=True,
            color=(0, 128, 0, 255),
            x=window.width//2, y=field.center_x + field.size // 6,
            anchor_x='center', anchor_y='center', batch=batch)
        self.update()
    def update(self):
        if not mode.started and update_available:
            str_list = []
            str_list.append('An update is available (')
            str_list.append(str(update_version))
            str_list.append('). Press W to open web site')
            self.label.text = ''.join(str_list)
        else: self.label.text = ''
        
# this is the black text above the field
class GameModeLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=16,
            color=COLOR_TEXT,
            x=window.width//2, y=window.height - 20,
            anchor_x='center', anchor_y='center', batch=batch)
        self.update()
    def update(self):
        if mode.started and mode.hide_text:
            self.label.text = ''
        else:
            str_list = []
            if JAEGGI_MODE and not CLINICAL_MODE:
                str_list.append('Jaeggi mode: ')
            if mode.manual:
                str_list.append('Manual mode: ')
            str_list.append(mode.long_mode_names[mode.mode] + ' ')
            if VARIABLE_NBACK == 1:
                str_list.append('V. ')
            str_list.append(str(mode.back))
            str_list.append('-Back')
            self.label.text = ''.join(str_list)

    def flash(self):
        pyglet.clock.unschedule(gameModeLabel.unflash)
        self.label.color = (255,0 , 255, 255)
        self.update()
        pyglet.clock.schedule_once(gameModeLabel.unflash, 0.5)
    def unflash(self, dt):
        self.label.color = COLOR_TEXT
        self.update()

class JaeggiWarningLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=12, bold = True,
            color=(255, 0, 255, 255),
            x=window.width//2, y=field.center_x + field.size // 3 + 8,
            anchor_x='center', anchor_y='center', batch=batch)

    def show(self):
        pyglet.clock.unschedule(jaeggiWarningLabel.hide)
        self.label.text = 'Please disable Jaeggi Mode to access additional modes.'
        pyglet.clock.schedule_once(jaeggiWarningLabel.hide, 3.0)
    def hide(self, dt):
        self.label.text = ''

# this is the keyboard reference list along the left side
class KeysListLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            multiline = True, width = 300, bold = False,
            font_size=9,
            color=COLOR_TEXT,
            x = 10,
            anchor_x='left', anchor_y='top', batch=batch)
        self.update()
    def update(self):
        str_list = []
        if mode.started:
            self.label.y = window.height - 10
            if not mode.hide_text:
                str_list.append('P: Pause / Unpause\n')
                str_list.append('\n')
                str_list.append('F8: Hide / Reveal Text\n')
                str_list.append('\n')                
                str_list.append('ESC: Cancel Session\n')
        elif CLINICAL_MODE:
            self.label.y = window.height - 10
            str_list.append('ESC: Exit')
        else:
            if mode.manual or JAEGGI_MODE:
                self.label.y = window.height - 10
            else:
                self.label.y = window.height - 40
            if USE_MORSE:
                str_list.append('J: Morse Code Reference\n')
                str_list.append('\n')
            str_list.append('H: Help / Tutorial\n')
            str_list.append('\n')
            if mode.manual:
                str_list.append('F1: Decrease N-Back\n')
                str_list.append('F2: Increase N-Back\n')
                str_list.append('\n')
                str_list.append('F3: Decrease Trials\n')
                str_list.append('F4: Increase Trials\n')
                str_list.append('\n')
            if mode.manual:
                str_list.append('F5: Decrease Speed\n')
                str_list.append('F6: Increase Speed\n')
                str_list.append('\n')
            str_list.append('C: Choose Game Type\n')
            str_list.append('S: Select Sounds\n')
            str_list.append('I: Select Images\n')
            if mode.manual:
                str_list.append('M: Standard Mode\n')
            else:
                str_list.append('M: Manual Mode\n')
            str_list.append('\n')
            str_list.append('G: Daily Progress Graph\n')
            str_list.append('\n')
            str_list.append('W: Brain Workshop Web Site\n')
            if WINDOW_FULLSCREEN:
                str_list.append('E: Saccadic Eye Exercise\n')
            str_list.append('\n')
            str_list.append('ESC: Exit\n')
            
        self.label.text = ''.join(str_list)

class TitleMessageLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            'Brain Workshop',
            #multiline = True, width = window.width // 2,
            font_size = 32, bold = True, color = COLOR_TEXT,
            x = window.width // 2, y = window.height - 35,
            anchor_x = 'center', anchor_y = 'center')
        self.label2 = pyglet.text.Label(
            'Version ' + str(VERSION),
            font_size = 14, bold = False, color = COLOR_TEXT,
            x = window.width // 2, y = window.height - 75,
            anchor_x = 'center', anchor_y = 'center')
        
    def draw(self):
        self.label.draw()
        self.label2.draw()

class TitleKeysLabel:
    def __init__(self):
        str_list = []
        if not (JAEGGI_MODE or CLINICAL_MODE):
            str_list.append('C: Choose Game Mode\n')
            str_list.append('S: Choose Sounds\n')
            str_list.append('I: Choose Images\n')
        if not CLINICAL_MODE:
            str_list.append('G: Daily Progress Graph\n')
        str_list.append('H: Help / Tutorial\n')
        if not CLINICAL_MODE:
            str_list.append('F: Go to Forum / Mailing List')
        
        self.keys = pyglet.text.Label(
            ''.join(str_list),
            multiline = True, width = 260,
            font_size = 12, bold = True, color = COLOR_TEXT,
            x = window.width // 2, y = 180,
            anchor_x = 'center', anchor_y = 'top')
        
        self.space = pyglet.text.Label(
            'Press SPACE to enter the Workshop',
            font_size = 20, bold = True, color = (32, 32, 255, 255),
            x = window.width // 2, y = 35,
            anchor_x = 'center', anchor_y = 'center')
    def draw(self):
        self.space.draw()
        self.keys.draw()

        
# this is the word "brain" above the brain logo.
class LogoUpperLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            'Brain',
            font_size=11, bold = True,
            color=COLOR_TEXT,
            x=field.center_x, y=field.center_y + 30,
            anchor_x='center', anchor_y='center')
    def draw(self):
        self.label.draw()

# this is the word "workshop" below the brain logo.
class LogoLowerLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            'Workshop',
            font_size=11, bold = True,
            color=COLOR_TEXT,
            x=field.center_x, y=field.center_y - 27,
            anchor_x='center', anchor_y='center')
    def draw(self):
        self.label.draw()

# this is the word "Paused" which appears when the game is paused.
class PausedLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=14,
            color=(64, 64, 255, 255),
            x=field.center_x, y=field.center_y,
            anchor_x='center', anchor_y='center', batch=batch)
        self.update()
    def update(self):
        if mode.paused:
            self.label.text = 'Paused'
        else:
            self.label.text = ''

# this is the congratulations message which appears when advancing N-back levels.
class CongratsLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=14,
            color=(255, 32, 32, 255),
            x=field.center_x, y=window.height - 47,
            anchor_x='center', anchor_y='center', batch=batch)
        self.update()
    def update(self, show=False, advance=False, fallback=False, awesome=False, great=False, good=False, perfect = False):
        str_list = []
        if show and not CLINICAL_MODE:
            if perfect: str_list.append('Perfect score! ')
            elif awesome: str_list.append('Awesome score! ')
            elif great: str_list.append('Great score! ')
            elif good: str_list.append('Not bad! ')
            else: str_list.append('Keep trying. You\'re getting there! ')
        if advance:
            str_list.append('N-Back increased')
        elif fallback:
            str_list.append('N-Back decreased')
        self.label.text = ''.join(str_list)
        
class ArithmeticAnswerLabel:
    def __init__(self):
        self.answer = []
        self.negative = False
        self.decimal = False
        self.label = pyglet.text.Label(
            '',
            x=window.width/2 - 40, y=30,
            anchor_x='left', anchor_y='center', batch=batch)
        self.update()
    def update(self):
        if mode.mode != 7 and mode.mode != 8 and mode.mode != 9:
            self.label.text = ''
            return
        if mode.started and mode.hide_text:
            self.label.text = ''
            return
        
        self.label.font_size = input_label_size()
        str_list = []
        str_list.append('Answer: ')
        str_list.append(str(self.parse_answer()))
        self.label.text = ''.join(str_list)
        
        if SHOW_FEEDBACK and mode.show_missed:
            result = check_match('arithmetic')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            if result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False
        
    def parse_answer(self):
        chars = ''.join(self.answer)
        if chars == '' or chars == '.':
            result = Decimal('0')
        else:
            result = Decimal(chars)
        if self.negative:
            result = Decimal('0') - result
        return result
            
    def input(self, input):
        if input == '-':
            if self.negative:
                self.negative = False
            else: self.negative = True
        elif input == '.' and not self.decimal:
            self.decimal = True
            self.answer.append(input)
        else:
            self.answer.append(input)
        self.update()
    
    def reset_input(self):
        self.answer = []
        self.negative = False
        self.decimal = False
        self.update()
                

# this controls the "A: position match" below the field.
class PositionLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            x=20, y=30,
            anchor_x='left', anchor_y='center', batch=batch)
        self.update()
    def update(self):
        self.label.font_size = input_label_size()
        if mode.started and mode.hide_text:
            self.label.text = ''
        elif mode.mode in (2, 3, 8, 9, 10, 20, 21, 25, 26, 101):
            str_list = [key.symbol_string(KEY_POSITION)]
            str_list.append(': position match')
            self.label.text = ''.join(str_list)
        elif mode.mode in (5, 6, 28, 104, 105, 107):
            str_list = []
            str_list.append(key.symbol_string(KEY_POSITION))
            str_list.append(': position')
            self.label.text = ''.join(str_list)
        else:
            self.label.text = ''
        if SHOW_FEEDBACK and mode.position_input:
            result = check_match('position')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            elif result == 'unknown':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
            elif result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        elif SHOW_FEEDBACK and (not mode.audiovis_input) and mode.show_missed:
            result = check_match('position', check_missed = True)
            if result == 'missed':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False
            
# this controls the "S: visual & n-visual" below the field.
class VisvisLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            y=30,
            anchor_y='center', batch=batch)
        self.update()
    def update(self):
        self.label.font_size = input_label_size()
        if mode.started and mode.hide_text:
            self.label.text = ''
        elif mode.mode in (4, 5, 6): # or mode.mode == 14 or mode.mode == 15 or mode.mode == 16:
            if mode.mode == 4: self.label.anchor_x = 'left'
            else: self.label.anchor_x = 'center'
            str_list = []
            str_list.append(key.symbol_string(KEY_VISVIS))
            str_list.append(': vis & n-vis')
            self.label.text = ''.join(str_list)
            if mode.mode == 4: # or mode.mode == 14:
                self.label.x = 20
            elif mode.mode == 5: # or mode.mode == 15:
                self.label.x = window.width // 4
            elif mode.mode == 6: # or mode.mode == 16:
                self.label.x = window.width // 5
        else:
            self.label.text = ''
        if SHOW_FEEDBACK and mode.visvis_input:
            result = check_match('visvis')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            elif result == 'unknown':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
            elif result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        elif SHOW_FEEDBACK and (not mode.audiovis_input) and mode.show_missed:
            result = check_match('visvis', check_missed = True)
            if result == 'missed':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False
        
# this controls the "D: visual & n-audio" below the field.
class VisaudioLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            y=30,
            anchor_x = 'center', anchor_y='center', batch=batch)
        self.update()
    def update(self):
        self.label.font_size = input_label_size()
        if mode.started and mode.hide_text:
            self.label.text = ''
        elif mode.mode == 4 or mode.mode == 5 or mode.mode == 6: # or mode.mode == 14 or mode.mode == 15 or mode.mode == 16:
            str_list = []
            str_list.append(key.symbol_string(KEY_VISAUDIO))
            str_list.append(': vis & n-sound')
            self.label.text = ''.join(str_list)
            if mode.mode == 4: # or mode.mode == 14:
                self.label.x = window.width // 3
            elif mode.mode == 5: # or mode.mode == 15:
                self.label.x = window.width // 2
            elif mode.mode == 6: # or mode.mode == 16:
                self.label.x = window.width // 5 * 2
        else:
            self.label.text = ''
        if SHOW_FEEDBACK and mode.visaudio_input:
            result = check_match('visaudio')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            elif result == 'unknown':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
            elif result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        elif SHOW_FEEDBACK and (not mode.audiovis_input) and mode.show_missed:
            result = check_match('visaudio', check_missed = True)
            if result == 'missed':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False

# this controls the "F: color match" below the field.
class ColorLabel:
    def __init__(self):
        self.label = pyglet.text.Label('',
            y=30,
            anchor_y='center', batch=batch)
        self.update()
    def update(self):
        self.label.font_size = input_label_size()
        if mode.started and mode.hide_text:
            self.label.text = ''
        elif mode.mode in (22, 24, 27, 102):
            self.label.text = '%s: color match' % key.symbol_string(KEY_COLOR)
            self.label.anchor_x = 'left'
            self.label.x = 20
        elif mode.mode in (3, 25):
            self.label.text = '%s: color match' % key.symbol_string(KEY_COLOR)
            self.label.anchor_x = 'center'
            self.label.x = window.width // 2
        elif mode.mode in (6, 28, 104, 106, 107):
            str_list = []
            str_list.append(key.symbol_string(KEY_COLOR))
            str_list.append(': color')
            self.label.text = ''.join(str_list)
            self.label.anchor_x = 'center'
            if mode.mode == 6:
                self.label.x = window.width // 5 * 3
            elif mode.mode == 28:
                self.label.x = window.width // 3 * 1
            elif mode.mode == 104:
                self.label.x = window.width // 3 * 1
            elif mode.mode == 106:
                self.label.anchor_x = 'left'
                self.label.x = 20
            elif mode.mode == 107:
                self.label.x = window.width // 4 * 1
        elif mode.mode in (9, 20):
            str_list = []
            str_list.append(key.symbol_string(KEY_COLOR))
            str_list.append(': color match')
            self.label.text = ''.join(str_list)
            self.label.anchor_x = 'right'
            self.label.x = window.width - 20
        else:
            self.label.text = ''
        if SHOW_FEEDBACK and mode.color_input:
            result = check_match('color')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            elif result == 'unknown':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
            elif result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        elif SHOW_FEEDBACK and (not mode.audiovis_input) and mode.show_missed:
            result = check_match('color', check_missed = True)
            if result == 'missed':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False

# this controls the "J: audio & n-visual" below the field.
class AudiovisLabel:
    def __init__(self):
        self.label = pyglet.text.Label('',
            x=window.width - window.width//5, y=30,
            anchor_x='center', anchor_y='center', batch=batch)
        self.update()
    def update(self):
        self.label.font_size = input_label_size()
        if mode.started and mode.hide_text:
            self.label.text = ''
        elif mode.mode in (4, 5, 6): # or mode.mode == 14 or mode.mode == 15 or mode.mode == 16:
            self.label.text = '%s: sound & n-vis' % key.symbol_string(KEY_AUDIOVIS)
            if mode.mode == 4: # or mode.mode == 14:
                self.label.x = window.width // 3 * 2
            elif mode.mode == 5: # or mode.mode == 15:
                self.label.x = window.width // 4 * 3
            elif mode.mode == 6: # or mode.mode == 16:
                self.label.x = window.width // 5 * 4
        else:
            self.label.text = ''
        if SHOW_FEEDBACK and mode.audiovis_input:
            result = check_match('audiovis')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            elif result == 'unknown':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
            elif result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        elif SHOW_FEEDBACK and (not mode.audiovis_input) and mode.show_missed:
            result = check_match('audiovis', check_missed = True)
            if result == 'missed':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False

# this controls the "J: image match" below the field.
class ImageLabel:
    def __init__(self):
        self.label = pyglet.text.Label('',
            y=30,
            anchor_y='center', batch=batch)
        self.update()
    def update(self):
        self.label.font_size = input_label_size()
        if mode.started and mode.hide_text:
            self.label.text = ''
        elif mode.mode in (23, 103):
            self.label.text = '%s: image match' % key.symbol_string(KEY_IMAGE)
            self.label.anchor_x = 'left'
            self.label.x = 20
        elif mode.mode in (26, 27):
            self.label.text = '%s: image match' % key.symbol_string(KEY_IMAGE)
            self.label.anchor_x = 'center'
            self.label.x = window.width // 2
        elif mode.mode in (28,):
            str_list = []
            str_list.append(key.symbol_string(KEY_IMAGE))
            str_list.append(': image')
            self.label.text = ''.join(str_list)
            self.label.anchor_x = 'center'
            self.label.x = window.width // 3 * 2   
        elif mode.mode in (105, 106):
            str_list = []
            str_list.append(key.symbol_string(KEY_IMAGE))
            str_list.append(': image')
            self.label.text = ''.join(str_list)
            self.label.anchor_x = 'center'
            self.label.x = window.width // 3
        elif mode.mode in (107,):
            str_list = []
            str_list.append(key.symbol_string(KEY_IMAGE))
            str_list.append(': image')
            self.label.text = ''.join(str_list)
            self.label.anchor_x = 'center'
            self.label.x = window.width // 4 * 2
        elif mode.mode in (21, 24, 25):
            str_list = []
            str_list.append(key.symbol_string(KEY_IMAGE))
            str_list.append(': image match')
            self.label.text = ''.join(str_list)
            self.label.anchor_x = 'right'
            self.label.x = window.width - 20
        else:
            self.label.text = ''
        if SHOW_FEEDBACK and mode.image_input:
            result = check_match('image')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            elif result == 'unknown':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
            elif result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        elif SHOW_FEEDBACK and (not mode.audiovis_input) and mode.show_missed:
            result = check_match('image', check_missed = True)
            if result == 'missed':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False

# this controls the "L: sound match" below the field.
class AudioLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            y=30,
            anchor_y='center', batch=batch)
        self.update()
    def update(self):
        self.label.font_size = input_label_size()
        if mode.started and mode.hide_text:
            self.label.text = ''
        elif mode.mode in (2, 3, 22, 23, 26, 27): # or mode.mode == 12 or mode.mode == 13:
            self.label.anchor_x='right'
            self.label.x=window.width-20
            self.label.text = '%s: sound match' % key.symbol_string(KEY_AUDIO)
        elif mode.mode in (4, 5, 6, 28): # or mode.mode == 14 or mode.mode == 15 or mode.mode == 16:
            self.label.anchor_x='right'
            self.label.x=window.width-20
            self.label.text = '%s: sound' % key.symbol_string(KEY_AUDIO)
        elif mode.mode in (100,):
            self.label.anchor_x='left'
            self.label.x=20
            self.label.text = '%s: sound match' % key.symbol_string(KEY_AUDIO)
        elif mode.mode in (101, 102, 103):
            self.label.anchor_x='center'
            self.label.x=window.width // 2
            self.label.text = '%s: sound match' % key.symbol_string(KEY_AUDIO)
        elif mode.mode in (104, 105, 106):
            self.label.anchor_x='center'
            self.label.x=window.width // 3 * 2
            self.label.text = '%s: sound' % key.symbol_string(KEY_AUDIO)
        elif mode.mode in (107,):
            self.label.anchor_x='center'
            self.label.x=window.width // 4 * 3
            self.label.text = '%s: sound' % key.symbol_string(KEY_AUDIO)
        else:
            self.label.text = ''
        if SHOW_FEEDBACK and mode.audio_input:
            result = check_match('audio')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            elif result == 'unknown':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
            elif result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        elif SHOW_FEEDBACK and (not mode.audiovis_input) and mode.show_missed:
            result = check_match('audio', check_missed = True)
            if result == 'missed':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False
            
# this controls the ";: sound2 match" below the field.
class Audio2Label:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            y=30,
            anchor_y='center', batch=batch)
        self.update()
    def update(self):
        if key.symbol_string(KEY_AUDIO2) == 'SEMICOLON':
            keytext = ';'
        else: keytext = key.symbol_string(KEY_AUDIO2)
        self.label.font_size = input_label_size()
        if mode.started and mode.hide_text:
            self.label.text = ''
        elif mode.mode in (100, 101, 102, 103):
            self.label.anchor_x='right'
            self.label.x=window.width-20
            self.label.text = '%s: sound2 match' % keytext
        elif mode.mode in (104, 105, 106, 107):
            self.label.anchor_x='right'
            self.label.x=window.width-20
            self.label.text = '%s: sound2' % keytext
        else:
            self.label.text = ''
        if SHOW_FEEDBACK and mode.audio2_input:
            result = check_match('audio2')
            if result == 'correct':
                self.label.color = COLOR_LABEL_CORRECT
                self.label.bold = True
            elif result == 'unknown':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
            elif result == 'incorrect':
                self.label.color = COLOR_LABEL_INCORRECT
                self.label.bold = True
        elif SHOW_FEEDBACK and (not mode.audiovis_input) and mode.show_missed:
            result = check_match('audio2', check_missed = True)
            if result == 'missed':
                self.label.color = COLOR_LABEL_OOPS
                self.label.bold = True
        else:
            self.label.color = COLOR_TEXT
            self.label.bold = False


# this is the text that shows the seconds per trial and the number of trials.
class SessionInfoLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            multiline = True, width = 128,
            font_size=11,
            color=COLOR_TEXT,
            x=20, y=field.center_y - 145,
            anchor_x='left', anchor_y='top', batch=batch)
        self.update()
    def update(self):
        if mode.started or CLINICAL_MODE:
            self.label.text = ''
        else:
            self.label.text = 'Session:\n%1.2f sec/trial\n%i+%i trials\n%i seconds' % \
                              (mode.ticks_per_trial / 10.0, mode.num_trials, \
                               mode.num_trials_total - mode.num_trials, 
                               int((mode.ticks_per_trial / 10.0) * \
                               (mode.num_trials_total)))
    def flash(self):
        pyglet.clock.unschedule(sessionInfoLabel.unflash)
        self.label.bold = True
        self.update()
        pyglet.clock.schedule_once(sessionInfoLabel.unflash, 1.0)
    def unflash(self, dt):
        self.label.bold = False
        self.update()
# this is the text that shows the seconds per trial and the number of trials.

class ThresholdLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            multiline = True, width = 155,
            font_size=11,
            color=COLOR_TEXT,
            x=window.width - 20, y=field.center_y - 145,
            anchor_x='right', anchor_y='top', batch=batch)
        self.update()
    def update(self):
        if mode.started or mode.manual or CLINICAL_MODE:
            self.label.text = ''
        else:
            self.label.text = u'Thresholds:\nRaise level: \u2265 %i%%\nLower level: < %i%%' % \
            (get_threshold_advance(), get_threshold_fallback())   # '\u2265' = '>='
        
# this controls the "press space to begin session #" text.
class SpaceLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=16,
            bold=True,
            color=(32, 32, 255, 255),
            x=window.width//2, y=62,
            anchor_x='center', anchor_y='center', batch=batch)
        self.update()
    def update(self):
        if mode.started:
            self.label.text = ''
        else: 
            str_list = []
            str_list.append('Press SPACE to begin session #')
            str_list.append(str(mode.session_number + 1))
            str_list.append(': ')
            str_list.append(mode.long_mode_names[mode.mode] + ' ')
                
            if VARIABLE_NBACK == 1:
                str_list.append('V. ')
            str_list.append(str(mode.back))
            str_list.append('-Back')
            self.label.text = ''.join(str_list)
        
def check_match(input_type, check_missed = False):
    current = 0
    back_data = ''
    operation = 0
    if VARIABLE_NBACK == 1:
        nback_trial = mode.trial_number - mode.variable_list[mode.trial_number - mode.back - 1] - 1
    elif VARIABLE_NBACK == 0:
        nback_trial = mode.trial_number - mode.back - 1
        
    if len(stats.session['position']) < mode.back:
        return 'unknown'
    if input_type == 'position':
        current = mode.current_position
        back_data = 'position'
    elif input_type == 'color':
        current = mode.current_color
        back_data = 'color'
    elif input_type == 'visvis':
        current = mode.current_vis
        back_data = 'vis'
    elif input_type == 'visaudio':
        current = mode.current_vis
        back_data = 'audio'
    elif input_type == 'audiovis':
        current = mode.current_audio
        back_data = 'vis'
    elif input_type == 'image':
        current = mode.current_vis
        back_data = 'vis'
    elif input_type == 'audio':
        current = mode.current_audio
        back_data = 'audio'
    elif input_type == 'audio2':
        current = mode.current_audio2
        back_data = 'audio2'    
    elif input_type == 'arithmetic':
        current = mode.current_number
        back_data = stats.session['numbers'][nback_trial]
        operation = mode.current_operation
        
    if input_type == 'arithmetic':
        if operation == 'add':
            correct_answer = back_data + current
        elif operation == 'subtract':
            correct_answer = back_data - current
        elif operation == 'multiply':
            correct_answer = back_data * current
        elif operation == 'divide':
            correct_answer = Decimal(back_data) / Decimal(current)
        if correct_answer == arithmeticAnswerLabel.parse_answer():
            return 'correct'
        
    elif current == stats.session[back_data][nback_trial]:
        if check_missed:
            return 'missed'
        else:
            return 'correct'
    return 'incorrect'

                
# this controls the statistics which display upon completion of a session.
class AnalysisLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=14,
            color=COLOR_TEXT,
            x=window.width//2, y=92,
            anchor_x='center', anchor_y='center', batch=batch)
        self.update()
        
    def update(self, skip = False):
        if mode.started or mode.session_number == 0 or skip:
            self.label.text = ''
            return
        
        rights = {'position':0, 'color':0, 'visvis':0, 'visaudio':0, 'audiovis':0, 'image':0, 'audio':0, 'audio2':0, 'arithmetic':0}
        wrongs = {'position':0, 'color':0, 'visvis':0, 'visaudio':0, 'audiovis':0, 'image':0, 'audio':0, 'audio2':0, 'arithmetic':0}
        category_percents = {
                  'position':0, 'color':0, 'visvis':0, 'visaudio':0, 'audiovis':0, 'image':0, 'audio':0, 'audio2':0, 'arithmetic':0}

        mods = mode.modalities[mode.mode]
        data = stats.session

        for mod in mods:
            for x in range(mode.back, len(data['position'])):

                back = mode.back
                if VARIABLE_NBACK:
                    back = mode.variable_list[x - mode.back]
                                
                # data is a dictionary of lists.
                if mod in ['position', 'audio', 'audio2', 'color', 'image']:
                    rights[mod] += int((data[mod][x] == data[mod][x-back]) and data[mod+'_input'][x])
                    wrongs[mod] += int((data[mod][x] == data[mod][x-back])  ^  data[mod+'_input'][x]) # XOR
                    if JAEGGI_MODE: 
                        rights[mod] += int(data[mod][x] != data[mod][x-back]  and not data[mod+'_input'][x])
                
                if mod in ['visvis', 'visaudio', 'audiovis']:
                    modnow = mod.startswith('vis') and 'vis' or 'audio' # these are the python<2.5 compatible versions
                    modthn = mod.endswith('vis')   and 'vis' or 'audio' # of 'vis' if mod.startswith('vis') else 'audio'
                    rights[mod] += int((data[modnow][x] == data[modthn][x-back]) and data[mod+'_input'][x])
                    wrongs[mod] += int((data[modnow][x] == data[modthn][x-back])  ^  data[mod+'_input'][x]) 
                    if JAEGGI_MODE: 
                        rights[mod] += int(data[modnow][x] != data[modthn][x-back]  and not data[mod+'_input'][x])
                    
                if mod in ['arithmetic']:
                    ops = {'add':'+', 'subtract':'-', 'multiply':'*', 'divide':'/'}
                    answer = eval("Decimal(data['numbers'][x-back]) %s Decimal(data['numbers'][x])" % ops[data['operation'][x]])
                    rights[mod] += int(answer == Decimal(data[mod+'_input'][x])) # data[...][x] is only Decimal if op == /
                    wrongs[mod] += int(answer != Decimal(data[mod+'_input'][x])) 
        
        str_list = []
        if not CLINICAL_MODE:
            str_list += ['Correct-Errors:   ']
            sep = '   '
            keys = {'position':KEY_POSITION, 'visvis':KEY_VISVIS, 'visaudio':KEY_VISAUDIO, 
                    'color':KEY_COLOR, 'audiovis':KEY_AUDIOVIS, 'image':KEY_IMAGE, 'audio':KEY_AUDIO,
                    'audio2':KEY_AUDIO2}
            
            for mod in ['position', 'visvis', 'visaudio', 'color', 'audiovis', 'image', 'audio', 'audio2']:
                if mod in mods:
                    if mod == 'audio2':
                        keytext = ';'
                    else: keytext = key.symbol_string(keys[mod])
                    str_list += ["%s:%i-%i%s" % (keytext, rights[mod], wrongs[mod], sep)]
    
            if 'arithmetic' in mods:
                str_list += ["%s:%i-%i%s" % ("Arithmetic", rights['arithmetic'], wrongs['arithmetic'], sep)]
             
        def calc_percent(r, w):
            if r+w: return int(r*100 / float(r+w))
            else:   return 0
            
        right = sum([rights[mod] for mod in mods])
        wrong = sum([wrongs[mod] for mod in mods])
        
        for mod in mods:
            category_percents[mod] = calc_percent(rights[mod], wrongs[mod])

        if not JAEGGI_MODE:
            percent = calc_percent(right, wrong)
            str_list += ['Score: %i%%' % percent]
        else:
            percent = min(category_percents['position'], category_percents['audio'])
            if CLINICAL_MODE:
                #str_list += [' Position score: %i%%' % category_percents['position']]
                #str_list += ['       Sound score: %i%%' % category_percents['audio']]
                pass
            else:
                str_list += ['Lowest score: %i%%' % percent]
        
        self.label.text = ''.join(str_list)
        stats.submit_session(percent, category_percents)
                    
# this controls the title of the session history chart.
class ChartTitleLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=11, bold=True,
            color=COLOR_TEXT,
            x=window.width - 10, y=window.height-25,
            anchor_x='right', anchor_y='top', batch=batch)
        self.update()
    def update(self):
        if mode.started:
            self.label.text = ''
        else:
            self.label.text = 'Today\'s Last 20:'

# this controls the session history chart.
class ChartLabel:
    def __init__(self):
        self.start_x = window.width - 140
        self.start_y = window.height - 65
        self.line_spacing = 15
        self.column_spacing_12 = 30
        self.column_spacing_23 = 70
        self.font_size = 10
        self.color_normal = (128, 128, 128, 255)
        self.color_advance = (0, 160, 0, 255)
        self.color_fallback = (160, 0, 0, 255)
        self.column1 = []
        self.column2 = []
        self.column3 = []
        for zap in range(0, 20):
            self.column1.append(pyglet.text.Label(
                '', font_size = self.font_size,
                x = self.start_x, y = self.start_y - zap * self.line_spacing,
                anchor_x = 'left', anchor_y = 'top', batch=batch))
            self.column2.append(pyglet.text.Label(
                '', font_size = self.font_size,
                x = self.start_x + self.column_spacing_12, y = self.start_y - zap * self.line_spacing,
                anchor_x = 'left', anchor_y = 'top', batch=batch))
            self.column3.append(pyglet.text.Label(
                '', font_size = self.font_size,
                x = self.start_x + self.column_spacing_12 + self.column_spacing_23, y = self.start_y - zap * self.line_spacing,
                anchor_x = 'left', anchor_y = 'top', batch=batch))
        stats.parse_statsfile()
        self.update()
        
    def update(self):
        for x in range(0, 20):
            self.column1[x].text = ''
            self.column2[x].text = ''
            self.column3[x].text = ''
        if mode.started: return
        index = 0
        for x in range(len(stats.history) - 20, len(stats.history)):
            if x < 0: continue
            manual = stats.history[x][4]
            color = self.color_normal
            if not manual and stats.history[x][3] >= get_threshold_advance():
                color = self.color_advance
            elif not manual and stats.history[x][3] < get_threshold_fallback():
                color = self.color_fallback
            self.column1[index].color = color
            self.column2[index].color = color
            self.column3[index].color = color
            if manual:
                self.column1[index].text = 'M'
            elif stats.history[x][0] > -1:
                self.column1[index].text = '#%i' % stats.history[x][0]
            self.column2[index].text = mode.short_name(mode=stats.history[x][1], back=stats.history[x][2])
            self.column3[index].text = '%i%%' % stats.history[x][3]
            index += 1
            
# this controls the title of the session history chart.
class AverageLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=9, bold=True,
            color=COLOR_TEXT,
            x=window.width - 10, y=window.height-45,
            anchor_x='right', anchor_y='top', batch=batch)
        self.update()
    def update(self):
        if mode.started or CLINICAL_MODE:
            self.label.text = ''
        else:
            sessions = [sess for sess in stats.history if sess[1] == mode.mode][-20:]
            if sessions:
                average = sum([sess[2] for sess in sessions]) / float(len(sessions))
            else:
                average = 0.
            self.label.text = "%sNB average: %1.2f" % (mode.short_mode_names[mode.mode], average)


class TodayLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=10, bold = True,
            color=COLOR_TEXT,
            x=window.width - 10, y=window.height-5,
            anchor_x='right', anchor_y='top', batch=batch)
        self.update()
    def update(self):
        if mode.started:
            self.label.text = ''
        else:
            self.label.text = 'Sessions today: %i' % stats.sessions_today

class TrialsRemainingLabel:
    def __init__(self):
        self.label = pyglet.text.Label(
            '',
            font_size=12, bold = True,
            color=COLOR_TEXT,
            x=window.width - 10, y=window.height-5,
            anchor_x='right', anchor_y='top', batch=batch)
        self.update()
    def update(self):
        if (not mode.started) or mode.hide_text:
            self.label.text = ''
        else:
            self.label.text = '%i remaining' % (mode.num_trials_total - mode.trial_number)
           
class Saccadic:
    def __init__(self):
        self.position = 'left'
        self.counter = 0
        self.radius = 10
        self.color = (0, 0, 255, 255)
    
    def tick(self, dt):
        self.counter += 1
        if self.counter == SACCADIC_REPETITIONS:
            self.stop()
        elif self.position == 'left':
            self.position = 'right'
        else: self.position = 'left'
        
    def start(self):
        self.position = 'left'
        mode.saccadic = True
        self.counter = 0
        pyglet.clock.schedule_interval(saccadic.tick, SACCADIC_DELAY)

    def stop(self):
        pyglet.clock.unschedule(saccadic.tick)
        mode.saccadic = False
        
    def draw(self):
        y = window.height / 2
        if saccadic.position == 'left':
            x = self.radius
        elif saccadic.position == 'right':
            x = window.width - self.radius
        pyglet.graphics.draw(4, GL_POLYGON, ('v2i', (
            x - self.radius, y - self.radius,  # lower-left
            x + self.radius, y - self.radius,  # lower-right
            x + self.radius, y + self.radius,  # upper-right
            x - self.radius, y + self.radius,  # upper-left
            
            )), ('c4B', self.color * 4))

#                    self.square = batch.add(40, GL_POLYGON, None, 
#                                            ('v2i', xy), ('c4B', self.color * 40))

#
# --- END GRAPHICS SECTION ----------------------------------------------
#

# this class stores the raw statistics and history information.
# the information is analyzed by the AnalysisLabel class.
class Stats:
    def __init__(self):
        # set up data variables
        self.initialize_session()
        self.history = []
        self.sessions_today = 0
        
    def parse_statsfile(self):
        if os.path.isfile(os.path.join(get_data_dir(), STATSFILE)):
            try:
                last_session = []
                last_session_number = 0
                last_mode = 0
                last_back = 0
                statsfile_path = os.path.join(get_data_dir(), STATSFILE)
                statsfile = open(statsfile_path, 'r')
                today = date.today()
                yesterday = date.fromordinal(today.toordinal() - 1)
                tomorrow = date.fromordinal(today.toordinal() + 1)
                for line in statsfile:
                    if line == '': continue
                    if line == '\n': continue
                    datestamp = date(int(line[:4]), int(line[5:7]), int(line[8:10]))
                    hour = int(line[11:13])
                    if int(strftime('%H')) < ROLLOVER_HOUR:
                        if datestamp == today:
                            pass
                        elif datestamp == yesterday and hour >= ROLLOVER_HOUR:
                            pass
                        else: continue
                    elif datestamp == today and hour >= ROLLOVER_HOUR:
                        pass
                    else: continue
                    if '\t' in line:
                        separator = '\t'
                    else: separator = ','
                    stats.sessions_today += 1
                    newline = line.split(separator)
                    newmode = int(newline[3])
                    newback = int(newline[4])
                    newpercent = int(newline[2])
                    newmanual = bool(int(newline[7]))
                    newsession_number = int(newline[8])
                    if newmanual:
                        newsession_number = 0
                    self.history.append([newsession_number, newmode, newback, newpercent, newmanual])
                    if not newmanual:
                        last_session = self.history[-1]
                statsfile.close()
                if last_session:
                    self.retrieve_progress(newmode=last_session[1])
            except:
                quit_with_error('Error parsing stats file\n%s' %
                                os.path.join(get_data_dir(), STATSFILE),
                                '\nPlease fix, delete or rename the stats file.',
                                quit=False)
    
    def retrieve_progress(self, newmode=None):
        if newmode:
            mode.mode = newmode
        else:
            newmode = mode.mode
        sessions = [s for s in self.history if s[1] == newmode]
        mode.enforce_standard_mode()
        if sessions:
            ls = sessions[-1]
            mode.mode = ls[1]
            if JAEGGI_MODE:
                mode.mode = 2
            mode.back = ls[2]
            if ls[3] >= get_threshold_advance():
                mode.back += 1
            mode.num_trials_total = mode.num_trials + mode.num_trials_factor * mode.back ** mode.num_trials_exponent
            mode.session_number = ls[0]
            mode.progress = 0
            for s in sessions:
                if s[2] == mode.back and s[3] < get_threshold_fallback():
                    mode.progress += 1
                elif s[2] != mode.back:
                    mode.progress = 0
            if mode.progress >= THRESHOLD_FALLBACK_SESSIONS:
                mode.progress = 0
                mode.back -= 1
                if mode.back < 1:
                    mode.back = 1

    def initialize_session(self):
        self.session = {}
        self.session['position'] = []
        self.session['color'] = []
        self.session['image'] = []
        self.session['audio'] = []
        self.session['audio2'] = []
        self.session['vis'] = []
        self.session['numbers'] = []
        self.session['operation'] = []
        
        self.session['position_input'] = []
        self.session['visvis_input'] = []
        self.session['visaudio_input'] = []
        self.session['color_input'] = []
        self.session['audiovis_input'] = []
        self.session['image_input'] = []
        self.session['audio_input'] = []
        self.session['audio2_input'] = []
        self.session['arithmetic_input'] = []

    def save_input(self):
        self.session['position'].append(mode.current_position)
        self.session['color'].append(mode.current_color)
        self.session['image'].append(mode.current_vis)
        self.session['audio'].append(mode.current_audio)
        self.session['audio2'].append(mode.current_audio2)
        self.session['vis'].append(mode.current_vis)
        self.session['numbers'].append(mode.current_number)
        self.session['operation'].append(mode.current_operation)

        self.session['position_input'].append(mode.position_input)
        self.session['visvis_input'].append(mode.visvis_input)
        self.session['visaudio_input'].append(mode.visaudio_input)
        self.session['color_input'].append(mode.color_input)
        self.session['audiovis_input'].append(mode.audiovis_input)
        self.session['image_input'].append(mode.image_input)
        self.session['audio_input'].append(mode.audio_input)
        self.session['audio2_input'].append(mode.audio2_input)
        self.session['arithmetic_input'].append(arithmeticAnswerLabel.parse_answer())

    def submit_session(self, percent, category_percents):
        global musicplayer
        global applauseplayer
        self.history.append([mode.session_number, mode.mode, mode.back, percent, mode.manual])
        
        if ATTEMPT_TO_SAVE_STATS:
            try:
                sep = STATS_SEPARATOR
                statsfile_path = os.path.join(get_data_dir(), STATSFILE)
                statsfile = open(statsfile_path, 'a')
                outlist = [strftime("%Y-%m-%d %H:%M:%S"),
                           mode.short_name(),
                           str(percent),
                           str(mode.mode),
                           str(mode.back),
                           str(mode.ticks_per_trial),
                           str(mode.num_trials_total),
                           str(int(mode.manual)),
                           str(mode.session_number),
                           str(category_percents['position']),
                           str(category_percents['audio']),
                           str(category_percents['color']),
                           str(category_percents['visvis']),
                           str(category_percents['audiovis']),
                           str(category_percents['arithmetic']),
                           str(category_percents['image']),
                           str(category_percents['visaudio']),
                           str(category_percents['audio2']),
                           ]
                statsfile.write(sep.join(outlist)) # adds sep between each element
                statsfile.write('\n')  # but we don't want a sep before '\n'
                statsfile.close()
                if CLINICAL_MODE:
                    #picklefile = open(statsfile_path.replace('.txt', '.dat'), 'ab')
                    picklefile = open(os.path.join(get_data_dir(), STATS_BINARY), 'ab')
                    pickle.dump([strftime("%Y-%m-%d %H:%M:%S"), mode.short_name(), 
                                 percent, mode.mode, mode.back, mode.ticks_per_trial,
                                 mode.num_trials_total, int(mode.manual),
                                 mode.session_number, category_percents['position'],
                                 category_percents['audio'], category_percents['color'],
                                 category_percents['visvis'], category_percents['audiovis'],
                                 category_percents['arithmetic'], category_percents['image'],
                                 category_percents['visaudio'], category_percents['audio2']],
                                picklefile, protocol=2)
                    picklefile.close()
            except:
                quit_with_error('Error writing to stats file\n%s' % 
                                os.path.join(get_data_dir(), STATSFILE),
                                '\nPlease check file and directory permissions.')

        perfect = False        
        awesome = False
        great = False
        good = False
        advance = False
        fallback = False
        
        if not mode.manual:
            if percent >= get_threshold_advance():
                mode.back += 1
                mode.num_trials_total = mode.num_trials + mode.num_trials_factor * mode.back ** mode.num_trials_exponent
                mode.progress = 0
                circles.update()
                if USE_APPLAUSE:
                    applauseplayer = pyglet.media.ManagedSoundPlayer()
                    applauseplayer.queue(random.choice(applausesounds))
                    applauseplayer.volume = SFX_VOLUME
                    applauseplayer.play()
                advance = True
            elif mode.back > 1 and percent < get_threshold_fallback():
                if JAEGGI_MODE:
                    mode.back -= 1
                    fallback = True
                else:
                    if mode.progress == THRESHOLD_FALLBACK_SESSIONS - 1:
                        mode.back -= 1
                        mode.num_trials_total = mode.num_trials + mode.num_trials_factor * mode.back ** mode.num_trials_exponent
                        fallback = True
                        mode.progress = 0
                        circles.update()
                    else:
                        mode.progress += 1
                        circles.update()
    
            if percent == 100: perfect = True
            elif percent >= get_threshold_advance(): awesome = True
            elif percent >= (get_threshold_advance() + get_threshold_fallback()) // 2: great = True
            elif percent >= get_threshold_fallback(): good = True
            congratsLabel.update(True, advance, fallback, awesome, great, good, perfect)
        
        if mode.manual and not USE_MUSIC_MANUAL:
            return
        
        if USE_MUSIC:
            musicplayer = pyglet.media.ManagedSoundPlayer()
            if percent >= get_threshold_advance() and resourcepaths['music']['advance']:
                musicplayer.queue(pyglet.media.load(random.choice(resourcepaths['music']['advance']), streaming = True))
            elif percent >= (get_threshold_advance() + get_threshold_fallback()) // 2 and resourcepaths['music']['great']:
                musicplayer.queue(pyglet.media.load(random.choice(resourcepaths['music']['great']), streaming = True))
            elif percent >= get_threshold_fallback() and resourcepaths['music']['good']:
                musicplayer.queue(pyglet.media.load(random.choice(resourcepaths['music']['good']), streaming = True))
            else: 
                return
            musicplayer.volume = MUSIC_VOLUME
            musicplayer.play()
        
    def clear(self):
        self.history = []
        self.sessions_today = 0
        
def update_all_labels(do_analysis = False):
    updateLabel.update()
    congratsLabel.update()
    if do_analysis:
        analysisLabel.update()
    else:
        analysisLabel.update(skip = True)
            
    pyglet.clock.tick(poll=True) # Prevent music/applause skipping 1

    gameModeLabel.update()
    keysListLabel.update()
    pausedLabel.update()
    sessionInfoLabel.update()
    thresholdLabel.update()
    spaceLabel.update()
    chartTitleLabel.update()
    chartLabel.update()
    
    pyglet.clock.tick(poll=True) # Prevent music/applause skipping 2
    
    averageLabel.update()
    todayLabel.update()
    trialsRemainingLabel.update()
   
    update_input_labels()
    
def update_input_labels():
    positionLabel.update()
    colorLabel.update()
    imageLabel.update()
    audioLabel.update()
    audio2Label.update()
    visvisLabel.update()
    visaudioLabel.update()
    audiovisLabel.update()
    arithmeticAnswerLabel.update()

# this function handles initiation of a new session.
def new_session():
    mode.tick = -9  # give a 1-second delay before displaying first trial
    mode.session_number += 1
    mode.trial_number = 0
    mode.started = True
    mode.paused = False
    circles.update()
    
    # initialize sounds
    choices = []
    #if mode.mode == 13 or mode.mode == 14 or mode.mode == 15 or mode.mode == 16:
        #choices.append('morse')
    #else:
    if USE_LETTERS:
        choices.append('letters')
    if USE_NUMBERS:
        choices.append('numbers')
    if USE_NATO:
        choices.append('nato')
    if USE_PIANO:
        choices.append('piano')
    if USE_MORSE:
        choices.append('morse')
    if not choices:
        choices.append('letters')
    mode.sound_mode = random.choice(choices)
    
    choices = []
    if USE_LETTERS_2:
        choices.append('letters')
    if USE_NUMBERS_2:
        choices.append('numbers')
    if USE_NATO_2:
        choices.append('nato')
    if USE_PIANO_2:
        choices.append('piano')
    if USE_MORSE_2:
        choices.append('morse')
    if not choices:
        choices.append('letters')
    mode.sound2_mode = random.choice(choices)
    
    visual.letters = random.sample(sounds[mode.sound_mode].keys(), 8)
    visual.letters2 = random.sample(sounds[mode.sound2_mode].keys(), 8)
    visual.choose_random_images(8)
    mode.soundlist = [sounds[mode.sound_mode][l] for l in visual.letters]
    mode.soundlist2 = [sounds[mode.sound2_mode][l] for l in visual.letters2]
            
    if JAEGGI_MODE:
        compute_bt_sequence()
        
    pyglet.clock.tick(poll=True) # Prevent music/applause skipping
        
    if VARIABLE_NBACK == 1:
        # compute variable n-back sequence using beta distribution
        mode.variable_list = []
        for index in range(0, mode.num_trials_total - mode.back):
            mode.variable_list.append(int(random.betavariate(mode.back / 2.0, 1) * mode.back + 1))
    field.crosshair_update()
    reset_input()
    stats.initialize_session()
    update_all_labels()
    pyglet.clock.schedule_interval(fade_out, 0.05)

# this function handles the finish or cancellation of a session.
def end_session(cancelled = False):
    if cancelled:
        mode.session_number -= 1
    if not cancelled:
        stats.sessions_today += 1
    visual.hide()
    mode.started = False
    mode.paused = False
    circles.update()
    field.crosshair_update()
    reset_input()
    if cancelled:
        update_all_labels()
    else:
        update_all_labels(do_analysis = True)
            
# this function causes the key labels along the bottom to revert to their
# "non-pressed" state for a new trial or when returning to the main screen.
def reset_input():
    mode.position_input = False
    mode.color_input = False
    mode.visvis_input = False
    mode.visaudio_input = False
    mode.audiovis_input = False
    mode.image_input = False
    mode.audio_input = False
    mode.audio2_input = False
    arithmeticAnswerLabel.reset_input()
    update_input_labels()

# this handles the computation of a round with exactly 6 position and 6 audio matches
# this function is not currently used -- compute_bt_sequence() is used instead
def new_compute_bt_sequence(matches=6, modalities=['audio', 'vis']):
    # not ready for visaudio or audiovis, doesn't get 
    seq = {}
    for m in modalities:
        seq[m] = [False]*mode.back + \
                 random.shuffle([True]*matches + 
                                [False]*(mode.num_trials_total - mode.back - matches))
        for i in range(mode.back):
            seq[m][i] = random.randint(1,8)

        for i in range(mode.back, len(seq[m])):
            if seq[m][i] == True:
                seq[m][i] = seq[m][i-mode.back]
            elif seq[m][i] == False:  # should be all other cases
                seq[m][i] = random.randint(1,7)
                if seq[m][i] >= seq[m][i-mode.back]:
                    seq[m][i] += 1
    mode.bt_sequence = seq.values()

def compute_bt_sequence():
    bt_sequence = []
    bt_sequence.append([])
    bt_sequence.append([])    
    for x in range(0, mode.num_trials_total):
        bt_sequence[0].append(0)
        bt_sequence[1].append(0)
    
    for x in range(0, mode.back):
        bt_sequence[0][x] = random.randint(1, 8)
        bt_sequence[1][x] = random.randint(1, 8)
        
    position = 0
    audio = 0
    both = 0
    
    # brute force it
    while True:
        position = 0
        for x in range(mode.back, mode.num_trials + mode.back):
            bt_sequence[0][x] = random.randint(1, 8)
            if bt_sequence[0][x] == bt_sequence[0][x - mode.back]:
                position += 1
        if position != 6:
            continue
        while True:
            audio = 0
            for x in range(mode.back, mode.num_trials + mode.back):
                bt_sequence[1][x] = random.randint(1, 8)
                if bt_sequence[1][x] == bt_sequence[1][x - mode.back]:
                    audio += 1
            if audio == 6:
                break
        both = 0
        for x in range(mode.back, mode.num_trials + mode.back):
            if bt_sequence[0][x] == bt_sequence[0][x - mode.back] and bt_sequence[1][x] == bt_sequence[1][x - mode.back]:
                both += 1
        if both == 2:
            break
    
    mode.bt_sequence = bt_sequence
    
# responsible for the random generation of each new stimulus (audio, color, position)
def generate_stimulus():
    # first, randomly generate all stimuli
    mode.current_position = random.randint(1, 8)
    mode.current_color = random.randint(1, 8)
    mode.current_vis = random.randint(1, 8)
    mode.current_audio = random.randint(1, 8)
    mode.current_audio2 = random.randint(1, 8)
    
    # treat arithmetic specially
    operations = []
    if ARITHMETIC_USE_ADDITION: operations.append('add')
    if ARITHMETIC_USE_SUBTRACTION: operations.append('subtract')
    if ARITHMETIC_USE_MULTIPLICATION: operations.append('multiply')
    if ARITHMETIC_USE_DIVISION: operations.append('divide')
    mode.current_operation = random.choice(operations)
    
    if ARITHMETIC_USE_NEGATIVES:
        min_number = 0 - ARITHMETIC_MAX_NUMBER
    else:
        min_number = 0
    max_number = ARITHMETIC_MAX_NUMBER
    
    if mode.current_operation == 'divide' and mode.mode in (7, 8, 9):
        if len(stats.session['position']) >= mode.back:
            number_nback = stats.session['numbers'][mode.trial_number - mode.back - 1]
            possibilities = []
            for x in range(min_number, max_number + 1):
                if x == 0:
                    continue
                if number_nback % x == 0:
                    possibilities.append(x)
                    continue
                frac = Decimal(abs(number_nback)) / Decimal(abs(x))
                if (frac % 1) in map(Decimal, ARITHMETIC_ACCEPTABLE_DECIMALS):
                    possibilities.append(x)
            mode.current_number = random.choice(possibilities)
        else:
            mode.current_number = random.randint(min_number, max_number)
            while mode.current_number == 0:
                mode.current_number = random.randint(min_number, max_number)
    else:
        mode.current_number = random.randint(min_number, max_number)
    
    # force a match?
    if mode.mode != 7 and mode.trial_number > mode.back and random.random() < CHANCE_OF_GUARANTEED_MATCH:
        # A match of a randomly chosen input type is guaranteed this trial.
        
        input_types = mode.modalities[mode.mode]

        choice = random.choice(input_types)
        if VARIABLE_NBACK == 1:
            nback_trial = mode.trial_number - mode.variable_list[mode.trial_number - mode.back - 1] - 1
        else:
            nback_trial = mode.trial_number - mode.back - 1

        if choice == 'position':
            mode.current_position = stats.session['position'][nback_trial]
        elif choice == 'color':
            mode.current_color = stats.session['color'][nback_trial]
        elif choice == 'visvis':
            mode.current_vis = stats.session['vis'][nback_trial]
        elif choice == 'visaudio':
            mode.current_vis = stats.session['audio'][nback_trial]
        elif choice == 'audiovis':
            mode.current_audio = stats.session['vis'][nback_trial]
        elif choice == 'image':
            mode.current_vis = stats.session['vis'][nback_trial]
        elif choice == 'audio':
            mode.current_audio = stats.session['audio'][nback_trial]
        elif choice == 'audio2':
            mode.current_audio2 = stats.session['audio2'][nback_trial]

    # set static stimuli according to mode.
    # default position is 0 (center)
    # default color is 1 (red) or 2 (black)
    # default vis is 0 (square)
    # audio is never static so it doesn't have a default.
    if not 'color'    in mode.modalities[mode.mode]: mode.current_color = VISUAL_COLOR
    if not 'position' in mode.modalities[mode.mode]: mode.current_position = 0
    if not 'visvis'   in mode.modalities[mode.mode] and \
     not 'arithmetic' in mode.modalities[mode.mode] and \
     not 'image'      in mode.modalities[mode.mode]: mode.current_vis = 0

    # in jaeggi mode, set using the predetermined sequence.
    if JAEGGI_MODE:
        mode.current_position = mode.bt_sequence[0][mode.trial_number - 1]
        mode.current_audio = mode.bt_sequence[1][mode.trial_number - 1]
    
    # initiate the chosen stimuli.
    # mode.current_audio is a number from 1 to 8.
    if mode.mode in (7, 8, 9) and mode.trial_number > mode.back:
        player = pyglet.media.ManagedSoundPlayer()
        player.queue(sounds['operations'][mode.current_operation])
        player.play()
    elif mode.mode in (2, 3, 4, 5, 6, 11, 22, 23, 26, 27, 28):
        player = pyglet.media.ManagedSoundPlayer()
        player.queue(mode.soundlist[mode.current_audio-1])
        player.play()
    elif mode.mode in (100, 101, 102, 103, 104, 105, 106, 107):
        # dual audio modes - two sound players
        player = pyglet.media.ManagedSoundPlayer()
        player.queue(mode.soundlist[mode.current_audio-1])
        player.min_distance = 100.0
        if CHANNEL_AUDIO == 'left':
            player.position = (-99.0, 0.0, 0.0)
        elif CHANNEL_AUDIO == 'right':
            player.position = (99.0, 0.0, 0.0)
        elif CHANNEL_AUDIO == 'center':
            #player.position = (0.0, 0.0, 0.0)
            pass
        player.play()
        
        player2 = pyglet.media.ManagedSoundPlayer()
        player2.queue(mode.soundlist2[mode.current_audio2-1])
        player2.min_distance = 100.0
        if CHANNEL_AUDIO2 == 'left':
            player2.position = (-99.0, 0.0, 0.0)
        elif CHANNEL_AUDIO2 == 'right':
            player2.position = (99.0, 0.0, 0.0)
        elif CHANNEL_AUDIO2 == 'center':
            #player2.position = (0.0, 0.0, 0.0)
            pass
        player2.play()
        
            
    if VARIABLE_NBACK == 1 and mode.trial_number > mode.back:
        variable = mode.variable_list[mode.trial_number - 1 - mode.back]
    else:
        variable = 0
    visual.spawn(mode.current_position, mode.current_color, mode.current_vis, mode.current_number, mode.current_operation, variable)

def toggle_manual_mode():
    if mode.manual:
        mode.manual = False
    else:
        mode.manual = True
    
    #if not mode.manual:
        #mode.enforce_standard_mode()
        
    update_all_labels()


# there are 3 event loops:
#   on_key_press: listens to the keyboard and acts when certain keys are pressed
#   on_draw:      draws everything to the screen something like 60 times per second
#   update(dt):   the session timer loop which controls the game during the sessions.
#                 Runs once every quarter-second.
#
# --- BEGIN EVENT LOOP SECTION ----------------------------------------------
#

#soundchoices = dict((k, True) for k in sounds.keys()) # debugging
#del soundchoices['operations']
# this is where the keyboard keys are defined.
@window.event
def on_key_press(symbol, modifiers):
    global CHANNEL_AUDIO
    global USE_LETTERS
    global USE_NUMBERS
    global USE_NATO
    global USE_PIANO
    global USE_MORSE
    global CHANNEL_AUDIO2
    global USE_LETTERS_2
    global USE_NUMBERS_2
    global USE_NATO_2
    global USE_PIANO_2
    global USE_MORSE_2
    global VARIABLE_NBACK
    global soundchoices
    
    if symbol == key.D and (modifiers & key.MOD_CTRL):
        dump_pyglet_info()
        
    elif mode.title_screen and not mode.draw_graph and not mode.game_select and not mode.image_select and not mode.sound_select:
        if symbol == key.ESCAPE or symbol == key.X:
            window.on_close()
            
        elif symbol == key.SPACE:
            mode.title_screen = False
            #mode.shrink_brain = True
            #pyglet.clock.schedule_interval(shrink_brain, 1/60.)
            
        elif symbol == key.C and not JAEGGI_MODE:
            mode.game_select = True
                                    
        elif symbol == key.H:
            webbrowser.open_new_tab(WEB_TUTORIAL)
                
        elif symbol == key.G:
#            sound_stop()
            graph.parse_stats()
            graph.graph = mode.mode
            mode.draw_graph = True
            
#        elif symbol == key.V: # debugging
#            Menu(soundchoices, title='Hello World!')
#        elif symbol == key.B:
#            print soundchoices
                
        elif symbol == key.I and not JAEGGI_MODE:
            mode.image_select = True

        elif symbol == key.S and not JAEGGI_MODE:
            mode.sound_select = True
    
        elif symbol == key.F:
            webbrowser.open_new_tab(WEB_FORUM)

    elif mode.draw_graph:
        if symbol == key.ESCAPE or symbol == key.G or symbol == key.X:
            mode.draw_graph = False
            
        #elif symbol == key.E and (modifiers & key.MOD_CTRL):
            #graph.export_data()

        elif symbol == key.N:
            graph.next_mode()
            
    elif mode.game_select:
        def execute_mode_change():
            if not mode.manual:
                mode.enforce_standard_mode()
                stats.retrieve_progress()
            update_all_labels()
            circles.update()
            mode.game_select = False
        
        if symbol == key.ESCAPE or symbol == key.C or symbol == key.X:
            mode.game_select = False
        elif symbol == key.V:
            if VARIABLE_NBACK == 1:
                VARIABLE_NBACK = 0
            else: VARIABLE_NBACK = 1
        elif symbol == key._0 or symbol == key.NUM_0:
            mode.mode = 10
            execute_mode_change()
        elif symbol == key._1 or symbol == key.NUM_1:
            mode.mode = 11
            execute_mode_change()
        elif symbol == key._2 or symbol == key.NUM_2:
            mode.mode = 2
            execute_mode_change()
        elif symbol == key._3 or symbol == key.NUM_3:
            mode.mode = 3
            execute_mode_change()
        elif symbol == key._4 or symbol == key.NUM_4:
            mode.mode = 4
            execute_mode_change()
        elif symbol == key._5 or symbol == key.NUM_5:
            mode.mode = 5
            execute_mode_change()
        elif symbol == key._6 or symbol == key.NUM_6:
            mode.mode = 6
            execute_mode_change()
        elif symbol == key._7 or symbol == key.NUM_7:
            mode.mode = 7
            execute_mode_change()
        elif symbol == key._8 or symbol == key.NUM_8:
            mode.mode = 8
            execute_mode_change()
        elif symbol == key._9 or symbol == key.NUM_9:
            mode.mode = 9
            execute_mode_change()
        elif symbol == key.Q:
            mode.mode = 20
            execute_mode_change()
        elif symbol == key.W:
            mode.mode = 21
            execute_mode_change()
        elif symbol == key.E:
            mode.mode = 22
            execute_mode_change()
        elif symbol == key.R:
            mode.mode = 23
            execute_mode_change()
        elif symbol == key.T:
            mode.mode = 24
            execute_mode_change()
        elif symbol == key.Y:
            mode.mode = 25
            execute_mode_change()
        elif symbol == key.U:
            mode.mode = 26
            execute_mode_change()
        elif symbol == key.I:
            mode.mode = 27
            execute_mode_change()
        elif symbol == key.O:
            mode.mode = 28
            execute_mode_change()

        elif symbol == key.A:
            mode.mode = 100
            execute_mode_change()
        elif symbol == key.S:
            mode.mode = 101
            execute_mode_change()
        elif symbol == key.D:
            mode.mode = 102
            execute_mode_change()
        elif symbol == key.F:
            mode.mode = 103
            execute_mode_change()
        elif symbol == key.G:
            mode.mode = 104
            execute_mode_change()
        elif symbol == key.H:
            mode.mode = 105
            execute_mode_change()
        elif symbol == key.J:
            mode.mode = 106
            execute_mode_change()
        elif symbol == key.K:
            mode.mode = 107
            execute_mode_change()
            
    elif mode.image_select:        
        if symbol in (key.ESCAPE, key.I, key.X, key.SPACE):
            mode.image_select = False                   
        
        elif symbol in (key._0, key.NUM_0) and len(IMAGE_SETS) > 0:
            visual.load_set(0)
            mode.image_select = False
        elif symbol in (key._1, key.NUM_1) and len(IMAGE_SETS) > 1:
            visual.load_set(1)
            mode.image_select = False
        elif symbol in (key._2, key.NUM_2) and len(IMAGE_SETS) > 2:
            visual.load_set(2)
            mode.image_select = False
        elif symbol in (key._3, key.NUM_3) and len(IMAGE_SETS) > 3:
            visual.load_set(3)
            mode.image_select = False
        elif symbol in (key._4, key.NUM_4) and len(IMAGE_SETS) > 4:
            visual.load_set(4)
            mode.image_select = False
        elif symbol in (key._5, key.NUM_5) and len(IMAGE_SETS) > 5:
            visual.load_set(5)
            mode.image_select = False
        elif symbol in (key._6, key.NUM_6) and len(IMAGE_SETS) > 6:
            visual.load_set(6)
            mode.image_select = False
        elif symbol in (key._7, key.NUM_7) and len(IMAGE_SETS) > 7:
            visual.load_set(7)
            mode.image_select = False
        elif symbol in (key._8, key.NUM_8) and len(IMAGE_SETS) > 8:
            visual.load_set(8)
            mode.image_select = False
        elif symbol in (key._9, key.NUM_9) and len(IMAGE_SETS) > 9:
            visual.load_set(9)
            mode.image_select = False
            
    elif mode.sound_select:
        if symbol in (key.ESCAPE, key.S, key.X, key.SPACE):
            mode.sound_select = False
        elif symbol == key.L:
            if CHANNEL_AUDIO == 'center':
                CHANNEL_AUDIO = 'left'
            elif CHANNEL_AUDIO == 'left':
                CHANNEL_AUDIO = 'right'
            elif CHANNEL_AUDIO == 'right':
                CHANNEL_AUDIO = 'center'
        elif symbol == key._1 or symbol == key.NUM_1:
            USE_LETTERS = not USE_LETTERS
        elif symbol == key._2 or symbol == key.NUM_2:
            USE_NUMBERS = not USE_NUMBERS
        elif symbol == key._3 or symbol == key.NUM_3:
            USE_NATO = not USE_NATO
        elif symbol == key._4 or symbol == key.NUM_4:
            USE_PIANO = not USE_PIANO
        elif symbol == key._5 or symbol == key.NUM_5:
            USE_MORSE = not USE_MORSE
        elif symbol == key.SEMICOLON:
            if CHANNEL_AUDIO2 == 'center':
                CHANNEL_AUDIO2 = 'left'
            elif CHANNEL_AUDIO2 == 'left':
                CHANNEL_AUDIO2 = 'right'
            elif CHANNEL_AUDIO2 == 'right':
                CHANNEL_AUDIO2 = 'center'
        elif symbol == key.Q:
            USE_LETTERS_2 = not USE_LETTERS_2
        elif symbol == key.W:
            USE_NUMBERS_2 = not USE_NUMBERS_2
        elif symbol == key.E:
            USE_NATO_2 = not USE_NATO_2
        elif symbol == key.R:
            USE_PIANO_2 = not USE_PIANO_2
        elif symbol == key.T:
            USE_MORSE_2 = not USE_MORSE_2
            
    
    elif mode.saccadic:
        if symbol in (key.ESCAPE, key.E, key.X, key.SPACE):
            saccadic.stop()
            
    elif not mode.started:
        
        if symbol == key.ESCAPE or symbol == key.X:
            if SKIP_TITLE_SCREEN:
                window.on_close()
            else:
                mode.title_screen = True
        
        elif symbol == key.SPACE:
            new_session()
                        
        elif CLINICAL_MODE:
            pass
            #if symbol == key.H:
                #webbrowser.open_new_tab(CLINICAL_TUTORIAL)
        # No elifs below this line at this indentation will be 
        # executed in CLINICAL_MODE
        
        elif symbol == key.E and WINDOW_FULLSCREEN:
            saccadic.start()
        
        elif symbol == key.G:
#            sound_stop()
            graph.parse_stats()
            graph.graph = mode.mode
            mode.draw_graph = True

        elif symbol == key.F1 and mode.manual:
            if mode.back > 1:
                mode.back -= 1
                gameModeLabel.flash()
                spaceLabel.update()
                sessionInfoLabel.update()
                
        elif symbol == key.F2 and mode.manual:
            mode.back += 1
            gameModeLabel.flash()
            spaceLabel.update()
            sessionInfoLabel.update()

        elif symbol == key.F3 and mode.num_trials > 5 and mode.manual:
            mode.num_trials -= 5
            mode.num_trials_total = mode.num_trials + mode.num_trials_factor * \
                mode.back ** mode.num_trials_exponent
            sessionInfoLabel.flash()

        elif symbol == key.F4 and mode.manual:
            mode.num_trials += 5
            mode.num_trials_total = mode.num_trials + mode.num_trials_factor * \
                mode.back ** mode.num_trials_exponent
            sessionInfoLabel.flash()            
            
            
        elif symbol == key.F5 and mode.manual:
            if mode.ticks_per_trial < TICKS_MAX:
                mode.ticks_per_trial += 1
                sessionInfoLabel.flash()
                        
        elif symbol == key.F6 and mode.manual:
            if mode.ticks_per_trial > TICKS_MIN:
                mode.ticks_per_trial -= 1
                sessionInfoLabel.flash()
                
        elif symbol == key.C and (modifiers & key.MOD_CTRL):
            stats.clear()
            chartLabel.update()
            averageLabel.update()
            todayLabel.update()
            mode.progress = 0
            circles.update()

        elif symbol == key.C:
            if JAEGGI_MODE:
                jaeggiWarningLabel.show()
                return
            mode.game_select = True
        
        elif symbol == key.I:
            if JAEGGI_MODE:
                jaeggiWarningLabel.show()
                return
            mode.image_select = True

        elif symbol == key.S:
            if JAEGGI_MODE:
                jaeggiWarningLabel.show()
                return
            mode.sound_select = True
            
        elif symbol == key.W:
            webbrowser.open_new_tab(WEB_SITE)
            if update_available:
                window.on_close()
            
        elif symbol == key.M:
            toggle_manual_mode()
            update_all_labels()
            mode.progress = 0
            circles.update()

        elif symbol == key.H:
            webbrowser.open_new_tab(WEB_TUTORIAL)
            
        elif symbol == key.J and USE_MORSE:
            webbrowser.open_new_tab(WEB_MORSE)
                            
                        
    # these are the keys during a running session.
    elif mode.started:            
        if (symbol == key.ESCAPE or symbol == key.X) and not CLINICAL_MODE:
            end_session(cancelled = True)
            
        elif symbol == key.P and not CLINICAL_MODE:
            mode.paused = not mode.paused
            pausedLabel.update()
            field.crosshair_update()
                
        elif symbol == key.F8 and not CLINICAL_MODE:
            mode.hide_text = not mode.hide_text
            update_all_labels()
                
        elif mode.tick != 0 and mode.trial_number > 0:
            if mode.mode == 7 or mode.mode == 8 or mode.mode == 9:
                if symbol == key.BACKSPACE or symbol == key.DELETE:
                    arithmeticAnswerLabel.reset_input()
                elif symbol == key.MINUS or symbol == key.NUM_SUBTRACT:
                    arithmeticAnswerLabel.input('-')
                elif symbol == key.PERIOD or symbol == key.NUM_DECIMAL:
                    arithmeticAnswerLabel.input('.')
                elif symbol == key._0 or symbol == key.NUM_0:
                    arithmeticAnswerLabel.input('0')
                elif symbol == key._1 or symbol == key.NUM_1:
                    arithmeticAnswerLabel.input('1')
                elif symbol == key._2 or symbol == key.NUM_2:
                    arithmeticAnswerLabel.input('2')
                elif symbol == key._3 or symbol == key.NUM_3:
                    arithmeticAnswerLabel.input('3')
                elif symbol == key._4 or symbol == key.NUM_4:
                    arithmeticAnswerLabel.input('4')
                elif symbol == key._5 or symbol == key.NUM_5:
                    arithmeticAnswerLabel.input('5')
                elif symbol == key._6 or symbol == key.NUM_6:
                    arithmeticAnswerLabel.input('6')
                elif symbol == key._7 or symbol == key.NUM_7:
                    arithmeticAnswerLabel.input('7')
                elif symbol == key._8 or symbol == key.NUM_8:
                    arithmeticAnswerLabel.input('8')
                elif symbol == key._9 or symbol == key.NUM_9:
                    arithmeticAnswerLabel.input('9')
                    
            if symbol == KEY_POSITION:
                mode.position_input = True
                positionLabel.update()
                
            if symbol == KEY_VISVIS:
                mode.visvis_input = True
                visvisLabel.update()
                
            if symbol == KEY_VISAUDIO:
                mode.visaudio_input = True
                visaudioLabel.update()
                
            if symbol == KEY_COLOR:
                mode.color_input = True
                colorLabel.update()
                
            if symbol == KEY_AUDIOVIS:
                mode.audiovis_input = True
                audiovisLabel.update()
                
            if symbol == KEY_IMAGE:
                mode.image_input = True
                imageLabel.update()

            if symbol == KEY_AUDIO:
                mode.audio_input = True
                audioLabel.update()
                
            if symbol == KEY_AUDIO2:
                mode.audio2_input = True
                audio2Label.update()
            
# the loop where everything is drawn on the screen.
@window.event
def on_draw():
    if mode.shrink_brain:
        return
    window.clear()
    if mode.draw_graph:
        graph.draw()
    elif mode.game_select:
        gameSelect.draw()
    elif mode.image_select:
        imageSelect.draw()
    elif mode.sound_select:
        soundSelect.draw()
    elif mode.saccadic:
        saccadic.draw()
    elif mode.title_screen:
        brain_graphic.draw()
        titleMessageLabel.draw()
        titleKeysLabel.draw()
    else:
        batch.draw()
        if not mode.started and not CLINICAL_MODE:
            brain_icon.draw()
            logoUpperLabel.draw()
            logoLowerLabel.draw()

# the event timer loop. Runs every 1/10 second. This loop controls the session
# game logic.
# During each trial the tick goes from 1 to ticks_per_trial-1 then back to 0.
# tick = 1: Input from the last trial is saved. Input is reset.
#             A new square appears and the sound cue plays. 
# tick = 6: the square disappears.
# tick = ticks_per_trial - 1: tick is reset to 0.
# tick = 1: etc.
def update(dt):
    if mode.started and not mode.paused: # only run the timer during a game
        mode.tick += 1
        if mode.tick == 1:
            mode.show_missed = False
            if mode.trial_number > 0:
                stats.save_input()
            mode.trial_number += 1
            trialsRemainingLabel.update()
            if mode.trial_number > mode.num_trials_total:
                end_session()
            else: generate_stimulus()
            reset_input()
        # Hide square at either the 0.5 second mark or sooner
        if mode.tick == 6 or mode.tick == mode.ticks_per_trial - 1:
            visual.hide()
        if mode.tick == mode.ticks_per_trial:
            mode.tick = 0
            mode.show_missed = True
            update_input_labels()
pyglet.clock.schedule_interval(update, TICK_DURATION)

angle = 0
def pulsate(dt):
    global angle
    if mode.started: return
    if not window.visible: return
    angle += 15
    if angle == 360:
        angle = 0
    r = 0
    g = 0
    b = 191 + min(64, int(80 * math.cos(math.radians(angle))))
    spaceLabel.label.color = (r, g, b, 255)
#pyglet.clock.schedule_interval(pulsate, 1/20.)
        
#
# --- END EVENT LOOP SECTION ----------------------------------------------
#


batch = pyglet.graphics.Batch()

try: 
    test_polygon = batch.add(4, GL_QUADS, None, ('v2i', (
        100, 100,
        100, 200,
        200, 200,
        200, 100)),
              ('c3B', (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)))
    test_polygon.delete()
except:
    quit_with_error('Error creating test polygon. Full text of error:\n')

# Instantiate the classes
mode = Mode()
field = Field()
visual = Visual()
stats = Stats()
graph = Graph()
circles = Circles()
saccadic = Saccadic()

gameSelect = GameSelect()
imageSelect = ImageSelect()
soundSelect = SoundSelect()
updateLabel = UpdateLabel()
gameModeLabel = GameModeLabel()
jaeggiWarningLabel = JaeggiWarningLabel()
keysListLabel = KeysListLabel()
logoUpperLabel = LogoUpperLabel()
logoLowerLabel = LogoLowerLabel()
titleMessageLabel = TitleMessageLabel()
titleKeysLabel = TitleKeysLabel()
pausedLabel = PausedLabel()
congratsLabel = CongratsLabel()
sessionInfoLabel = SessionInfoLabel()
thresholdLabel = ThresholdLabel()
spaceLabel = SpaceLabel()
analysisLabel = AnalysisLabel()
chartTitleLabel = ChartTitleLabel()
chartLabel = ChartLabel()
averageLabel = AverageLabel()
todayLabel = TodayLabel()
trialsRemainingLabel = TrialsRemainingLabel()

arithmeticAnswerLabel = ArithmeticAnswerLabel()
positionLabel = PositionLabel()
colorLabel = ColorLabel()
imageLabel = ImageLabel()
audioLabel = AudioLabel()
audio2Label = Audio2Label()
visvisLabel = VisvisLabel()
visaudioLabel = VisaudioLabel()
audiovisLabel = AudiovisLabel()

update_all_labels()

# Initialize brain sprite
brain_icon = pyglet.sprite.Sprite(pyglet.image.load(random.choice(resourcepaths['misc']['brain'])))
brain_icon.set_position(field.center_x - brain_icon.width//2,
                           field.center_y - brain_icon.height//2)
if BLACK_BACKGROUND:
    brain_graphic = pyglet.sprite.Sprite(pyglet.image.load(random.choice(resourcepaths['misc']['splash-black'])))
else:
    brain_graphic = pyglet.sprite.Sprite(pyglet.image.load(random.choice(resourcepaths['misc']['splash'])))
brain_graphic.set_position(field.center_x - brain_graphic.width//2,
                           field.center_y - brain_graphic.height//2 + 40)

def shrink_brain(dt):
    brain_graphic.scale -= dt * 2
    brain_graphic.x = field.center_x - brain_graphic.image.width//2  + 2 + (brain_graphic.image.width - brain_graphic.width) // 2
    brain_graphic.y = field.center_y - brain_graphic.image.height//2 - 1 + (brain_graphic.image.height - brain_graphic.height) // 2
    window.clear()
    brain_graphic.draw()
    if brain_graphic.width < 56:
        mode.shrink_brain = False
        pyglet.clock.unschedule(shrink_brain)
        brain_graphic.scale = 1
        brain_graphic.set_position(field.center_x - brain_graphic.width//2,
                           field.center_y - brain_graphic.height//2 + 40)
        

# start the event loops!
if __name__ == '__main__':
    
    pyglet.app.run()

# nothing below the line "pyglet.app.run()" will be executed until the
# window is closed or ESC is pressed.

